## ams_version=1.0

Model IESA_Opt_Package {
	Section Model_description {
		DeclarationSection Temporal_relations {
			Set hours {
				SubsetOf: hours_orig;
				Index: h, ih;
				Property: ElementsAreNumerical;
				Definition: {
					{ho | ho <= card(hours_Orig)*hoursPer_day/24}
				}
			}
			Set hours_orig {
				SubsetOf: Integers;
				Index: ho, iho, jho;
				Property: ElementsAreNumerical;
			}
			Set hours_inDay {
				SubsetOf: hours;
				Index: h_d, ih_d;
				Definition: {
					{h | h<=hoursPer_day}
				}
			}
			Set hoursPer_dayOptions {
				SubsetOf: Integers;
				Property: ElementsAreNumerical;
				Definition: {
					{24,12,8,6,4,3,2,1}
				}
			}
			Set range_type;
			Set q_hourWindow {
				SubsetOf: Integers;
				Index: q, iq;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 365*hoursPer_day/hoursPer_quarter>=h>0}
				}
			}
			Set days {
				SubsetOf: Integers;
				Index: d, id;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 365>=h>0}
				}
			}
			Set r_dayWindow {
				SubsetOf: Integers;
				Index: r, ir;
				Definition: {
					{h | ceil(365/daysPer_range)>=h>0}
				}
			}
			Set weeks {
				SubsetOf: Integers;
				Index: w, iw;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 53>=h>0}
				}
			}
			Set months {
				SubsetOf: Integers;
				Index: m, im;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 12>=h>0}
				}
			}
			Set seasons {
				SubsetOf: Integers;
				Index: s, is;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 4>=h>0}
				}
			}
			Set b_semester {
				SubsetOf: Integers;
				Index: b, ib;
				Property: ElementsAreNumerical;
				Definition: {
					{h | 2>=h>0}
				}
			}
			Set periods {
				SubsetOf: Integers;
				Index: p, ip, jp;
				Property: ElementsAreNumerical;
				InitialData: {
					{2020,2025,2030,2035,2040,2045,2050}
				}
			}
			ElementParameter hoursPer_day {
				Range: hoursPer_dayOptions;
				Property: Constant;
				InitialData: '1';
			}
			ElementParameter hoursindayPer_hour {
				IndexDomain: h;
				Range: hours_inDay;
				Definition: {
					if(mod(h,hoursPer_day)=0) then
						hoursPer_day
					else
						mod(h,hoursPer_day)
					endif
				}
			}
			Parameter hoursPer_hourOrig {
				IndexDomain: ho;
				Definition: ceil(ho*hoursPer_day/24);
			}
			ElementParameter hoursOrigPer_hour {
				IndexDomain: h;
				Range: hours_orig;
				Definition: h*24/hoursPer_day;
			}
			ElementParameter quarterPer_hour {
				IndexDomain: h;
				Range: q_hourWindow;
				Definition: ceil(h/hoursPer_quarter);
			}
			ElementParameter dayPer_hour {
				IndexDomain: h;
				Range: days;
				Definition: ceil(h/hoursPer_day);
			}
			ElementParameter rangePer_hour {
				IndexDomain: h;
				Range: r_dayWindow;
				Definition: ceil(h/(hoursPer_day*daysPer_range));
			}
			ElementParameter weekPer_hour {
				IndexDomain: h;
				Range: weeks;
				Definition: ceil(h/(hoursPer_day*7));
			}
			ElementParameter monthPer_hour {
				IndexDomain: h;
				Range: months;
				Definition: monthPer_hourOrig(hoursOrigPer_hour(h));
			}
			ElementParameter monthPer_hourOrig {
				IndexDomain: ho;
				Range: Integers;
			}
			ElementParameter seasonPer_hour {
				IndexDomain: h;
				Range: seasons;
				Definition: ceil(4*h/card(h));
			}
			ElementParameter semesterPer_hour {
				IndexDomain: h;
				Range: b_semester;
				Definition: ceil(2*h/card(h));
			}
			ElementParameter rangePer_day {
				IndexDomain: d;
				Range: r_dayWindow;
				Definition: sum[ih | ih=hoursPer_day*d, rangePer_hour(ih)];
			}
			ElementParameter weekPer_day {
				IndexDomain: d;
				Range: weeks;
				Definition: sum[ih | ih=hoursPer_day*d, weekPer_hour(ih)];
			}
			ElementParameter monthPer_day {
				IndexDomain: d;
				Range: months;
				Definition: sum[ih | ih=hoursPer_day*d, monthPer_hour(ih)];
			}
			ElementParameter seasonPer_day {
				IndexDomain: d;
				Range: seasons;
				Definition: sum[ih | ih=hoursPer_day*d, seasonPer_hour(ih)];
			}
			ElementParameter semesterPer_day {
				IndexDomain: d;
				Range: b_semester;
				Definition: sum[ih | ih=hoursPer_day*d, semesterPer_hour(ih)];
			}
			Parameter hoursPer_quarter {
				Definition: max(1,hoursPer_day/4);
			}
			Parameter daysPer_range {
				Definition: 3;
			}
			Parameter transition_interval {
				Definition: val(last(periods)) - val(first(periods)) + 10;
			}
			Parameter modelled_transition_interval {
				Definition: val(last(periods_selection)) - val(first(periods_selection)) + last_period_length;
			}
			Parameter last_period_length {
				InitialData: 10;
			}
		}
		DeclarationSection System_info {
			Set typesInfo_tech {
				Index: tit, itit;
				Definition: {
					{'Name','Units_of_Capacity','Node','Category','Sector','Sub_sector','Activity','Units_of_Activity'}
				}
			}
			Set typesInfo_act {
				Index: tia, itia;
				Definition: {
					{'Node','Units_of_Activity'}
				}
			}
			Set sectors {
				SubsetOf: set_of_everything;
				Index: z, iz;
			}
			Set node_names {
				Index: nn, inn, jnn;
			}
			Set tech_nominals {
				Index: tn, itn, jtn;
			}
			Set tech_flex {
				SubsetOf: technologies;
				Index: tff, itff;
				Definition: {
					{t in tech_hourlyCHPflex}+{t in tech_shedding}+{t in tech_flexible}
				}
			}
			Set tech_imports {
				SubsetOf: tech_balancers;
				Index: tim, itim, jtim;
				Definition: {
					{tb | (StringOccurrences(tech_name(tb),'Import')*IEM_node(nodePer_techBal(tb)))>0}
				}
			}
			Set energy_labels {
				SubsetOf: set_of_everything;
				Index: el, iel, jel;
			}
			Set renewables {
				SubsetOf: energy_labels;
				Definition: {
					!if ('Wind' in energy_labels) then
					!	{'Wind','Solar','Biomass','Bio-liquids','Other RE'}
					!endif
					{el | is_renewable(el)=1}
				}
			}
			StringParameter tech_name {
				IndexDomain: t;
			}
			StringParameter tech_category {
				IndexDomain: t;
			}
			ElementParameter tech_sector {
				IndexDomain: t;
				Range: sectors;
			}
			StringParameter tech_subsector {
				IndexDomain: t;
			}
			ElementParameter tech_activity {
				IndexDomain: t;
				Range: activities_solve;
				Definition: {
					if (t in tech_balancers) then
						activityPer_tech(t)
					elseif (t in tech_infra) then
						infra_activity(t)
					endif
				}
			}
			StringParameter tech_units {
				IndexDomain: t;
			}
			StringParameter act_units {
				IndexDomain: a;
			}
			ElementParameter namePer_node {
				IndexDomain: n;
				Range: node_names;
			}
			Parameter IEM_node {
				IndexDomain: n;
				Range: binary;
			}
			Parameter IEM_sector {
				IndexDomain: z;
			}
			Parameter is_renewable {
				IndexDomain: el;
			}
			Parameter GWtoPJ_y {
				Definition: 3.6*8760/1000;
			}
			Parameter GWhtoPJ {
				Definition: 3.6/1000;
			}
			StringParameter tech_info {
				IndexDomain: (t,tit);
				Definition: {
					if (tit='Name') then
						tech_name(t)
					elseif (tit='Units_of_Capacity') then
						tech_units(t)
					elseif (tit='Node') then
						if (t in tech_balancers) then
							namePer_node(nodePer_techBal(t))
						elseif (t in tech_infra) then
							namePer_node(nodePer_techInfra(t))
						endif
					elseif (tit='Category') then
						tech_category(t)
					elseif (tit='Sector') then
						tech_sector(t)
					elseif (tit='Sub_sector') then
						tech_subsector(t)
					elseif (tit='Activity') then
						tech_activity(t)
					elseif (tit='Units_of_Activity') then
						act_units(tech_activity(t))
					endif
				}
			}
			StringParameter act_info {
				IndexDomain: (a,tia);
				Definition: {
					if (tia='Node') then
						namePer_node(nodePer_act(a))
					elseif (tia='Units_of_Activity') then
						act_units(a)
					endif
				}
			}
			StringParameter flexType_tech {
				IndexDomain: (tff);
				Definition: {
					if (tff in tech_hourlyCHPflex) then
						"CHP"
					elseif (tff in tech_shedding) then
						"Shedding"
					elseif (tff in tech_fDRshifting) then
						"Load Shifting"
					elseif (tff in tech_fBEshifting) then
						"Passive Storage"
					elseif (tff in tech_fStorage) then
						"Storage"
					elseif (tff in tech_fEVcharging) then
						"Smart Charging"
					elseif (tff in tech_fEVgrid) then
						"Vehicle-to-grid"
					endif
					!{,'Shedding','Storage','Load Shifting','Smart Charging','Vehicle-to-Grid','Passive Storage'}
				}
			}
			ElementParameter flexAct_tech {
				IndexDomain: (tff);
				Range: activities_hour;
				Definition: {
					if (tff in tech_hourlyCHPflex) then
						first({ah | dP_electricity(tff,ah)=1})
					elseif (tff in tech_shedding) then
						first({ah | dS_hourly(tff,ah)=1})
					else
						first({ah | dQ_hourly(tff,ah)=1})
					endif
					!{,'Shedding','Storage','Load Shifting','Smart Charging','Vehicle-to-Grid','Passive Storage'}
				}
			}
			StringParameter flex_info {
				IndexDomain: (tff,a);
				Definition: {
					if (a=flexAct_tech(tff)) then
						flexType_tech(tff)
					endif
				}
			}
			StringParameter scenario_description;
			StringParameter act_string {
				Definition: "Activity";
			}
			StringParameter day_string {
				Definition: "Day";
			}
			StringParameter energy_string {
				Definition: "Carrier";
			}
			StringParameter from_string {
				Definition: "from";
			}
			StringParameter hour_string {
				Definition: "Hour";
			}
			StringParameter name_string {
				Definition: "Name";
			}
			StringParameter node_string {
				Definition: "Node";
			}
			StringParameter sector_string {
				Definition: "Sector";
			}
			StringParameter sink_string {
				Definition: "Sink";
			}
			StringParameter source_string {
				Definition: "Source";
			}
			StringParameter techID_string {
				Definition: "Tech_ID";
			}
			StringParameter to_string {
				Definition: "to";
			}
			StringParameter type_string {
				Definition: "Type";
			}
			StringParameter type1_string {
				Definition: "Type1";
			}
			StringParameter type2_string {
				Definition: "Type2";
			}
			StringParameter week_string {
				Definition: "Week";
			}
		}
		DeclarationSection Balancing_description {
			Set set_of_everything;
			Set dispatch_type {
				Index: ym;
			}
			Set activity_type {
				Index: ya;
			}
			Set aktivities {
				SubsetOf: set_of_everything;
				Index: a;
				Definition: activities_original+activities_group;
			}
			Set activities_solve {
				SubsetOf: aktivities;
				Index: as, ias;
				Definition: {
					{ao | sum[ag,groupOf_activities(ag,ao)]=0}+activities_group
				}
			}
			Set activities_original {
				SubsetOf: aktivities;
				Index: ao, iao;
			}
			Set activities_group {
				SubsetOf: aktivities;
				Index: ag;
			}
			Set activities_driver {
				SubsetOf: activities_solve;
				Index: av, iav;
				Definition: {
					{as |activityType_act(as)='Driver'}
				}
			}
			Set activities_energy {
				SubsetOf: activities_solve;
				Index: ae, iae;
				Definition: {
					{as |activityType_act(as)='Energy'} + {as |activityType_act(as)='Fix Energy'}
				}
			}
			Set activities_fixenergy {
				SubsetOf: activities_solve;
				Index: af, iaf, jaf;
				Definition: {
					{as |activityType_act(as)='Fix Energy'}
				}
			}
			Set activities_materialconversion {
				SubsetOf: activities_solve;
				Index: amc, iamc, jamc;
				Definition: {
					{as | activityType_act(as)='Material conversion'}
				}
			}
			Set activities_energynonfixed {
				SubsetOf: activities_solve;
				Index: aen, iaen, jaen;
				Definition: {
					{as |activityType_act(as)='Energy'}
				}
			}
			Set activities_emission {
				SubsetOf: activities_solve;
				Index: ac, iac;
				Definition: {
					{as |activityType_act(as)='Emission'}
				}
			}
			Set activities_target {
				SubsetOf: activities_emission;
				Index: act, iact, jact;
				Definition: {
					{ac | emmisionTarget_bin(ac)=1 }
				}
			}
			Set activities_year {
				SubsetOf: activities_energy;
				Index: ay, iay, jay;
				Definition: {
					{ae | ((ae in activities_hour) + (ae in activities_day))=0}
				}
			}
			Set technologies {
				Index: t, it, jt;
			}
			Set tech_balancers {
				SubsetOf: technologies;
				Index: tb, itb, jtb;
			}
			Set tech_emission {
				SubsetOf: technologies;
				Index: t_c;
				Definition: {
					{t |activityType_act(activityPer_tech(t))='Emission'}
				}
			}
			Set nodes {
				Index: n, jn;
			}
			Set nodes_IEM {
				SubsetOf: nodes;
				Index: ni, ini, jni;
				Definition: {
					{n | IEM_node(n)=1}
				}
			}
			ElementParameter dispatchType_act {
				IndexDomain: a;
				Range: dispatch_type;
			}
			ElementParameter activityType_act {
				IndexDomain: a;
				Range: activity_type;
			}
			ElementParameter actSolvePer_actOrig {
				IndexDomain: ao;
				Range: activities_solve;
				Definition: {
					if (sum[ag, groupOf_activities(ag,ao)]=0) then
						ao
					else
						first({as | groupOf_activities(as,ao)=1})
					endif
				}
			}
			ElementParameter activityPer_techOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter activityPer_tech {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(activityPer_techOrig(tb));
			}
			ElementParameter nodePer_act {
				IndexDomain: a;
				Range: nodes;
			}
			ElementParameter nodePer_techBal {
				IndexDomain: tb;
				Range: nodes;
				Definition: nodePer_act(activityPer_tech(tb));
			}
			ElementParameter labelPer_act {
				IndexDomain: as;
				Range: energy_labels;
			}
			Parameter emissionTarget {
				IndexDomain: (n,p);
			}
			Parameter emissionTarget_cum {
				IndexDomain: n;
			}
			Parameter emmisionTarget_bin {
				IndexDomain: a;
				Range: binary;
			}
			Parameter roomFor_negative;
			Parameter cumulative_emissions {
				IndexDomain: n;
			}
			Parameter cumulative_CO2storage {
				IndexDomain: n;
			}
			Parameter XC_TransmissionLoss;
			Parameter HVtoMV_TransformerLoss;
			Parameter MVtoLV_TransformerLoss;
			Parameter HVtoLV_TransformerLoss;
			Parameter groupOf_activities {
				IndexDomain: (ag,ao);
				Range: binary;
			}
			Parameter activities_netVolumesOrig {
				IndexDomain: (ao,p);
			}
			Parameter activities_netVolumes {
				IndexDomain: (as,p);
				Definition: activities_netVolumesOrig(as,p)+sum[iao | groupOf_activities(as,iao)=1, activities_netVolumesOrig(iao,p)];
			}
			Parameter activity_balancesRef {
				IndexDomain: (tb,ao);
			}
			Parameter activity_EffImprov {
				IndexDomain: (tb,ao,p);
			}
			Parameter activity_balancesOrig {
				IndexDomain: (tb,ao,p);
				Definition: activity_balancesRef(tb,ao)*(1-activity_EffImprov(tb,ao,p));
			}
			Parameter activity_balances {
				IndexDomain: (tb,as,p);
				Definition: round((activity_balancesOrig(tb,as,p)+sum[iao | groupOf_activities(as,iao)=1, activity_balancesOrig(tb,iao,p)]),5);
			}
			Parameter vom_cost {
				IndexDomain: (tb,p);
			}
			Parameter cap2act {
				IndexDomain: t;
			}
			Variable tech_use {
				IndexDomain: (tb,ps);
				Range: nonnegative;
			}
			Constraint balance_activities {
				IndexDomain: (as,ps) | not (as in activities_fixenergy);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,as,ps)]+  !Reference activity balance
					sum[tf, sum[h, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))]*dQ_hourly(tf,as)]+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))]*activity_balances(tg,as,ps)]+ !Impact of gas buffers energy consumption
					sum[tk, sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,as,ps)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, deltaP_CHP(h,tk,ps)]*dP_electricity(tk,as)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -CHP_eta(tk)*deltaP_CHP(h,tk,ps)/CHP_eps(tk,ps)]*dP_heat(tk,as)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,as,ps)] !Impact of shedding load
					-sum[tw, sum[h, deltaW_UP(h,tw,ps)]*dW_hourly(tw,as)] !Demand increase due to pumping electricity in reservoirs
					>=activities_netVolumes(as,ps) !Exogenous drivers
					!plus a comment
				}
			}
			Constraint balance_activitiesFix {
				IndexDomain: (af,ps);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,af,ps)]+  !Reference activity balance
					sum[tf, sum[h, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))]*dQ_hourly(tf,af)]+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))]*activity_balances(tg,as,ps)]+ !Impact of gas buffers energy consumption
					sum[tk, sum[h, deltaU_CHP(h,tk,ps)]*activity_balances(tk,af,ps)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, deltaP_CHP(h,tk,ps)]*dP_electricity(tk,af)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -CHP_eta(tk)*deltaP_CHP(h,tk,ps)/CHP_eps(tk,ps)]*dP_heat(tk,af)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, deltaS_shed(h,ts,ps)]*activity_balances(ts,af,ps)] !Impact of shedding load
					-sum[tw, sum[h, deltaW_UP(h,tw,ps)]*dW_hourly(tw,af)] !Demand increase due to pumping electricity in reservoirs
					=activities_netVolumes(af,ps) !Exogenous drivers
				}
			}
			Constraint balance_activitiesmatconv {
				IndexDomain: (amc,ps);
				Definition: {
					sum[tb, tech_use(tb,ps)*activity_balances(tb,amc,ps)]  !Reference activity balance
					=activities_netVolumes(amc,ps) !Exogenous drivers
				}
			}
			Constraint capacity_technologies {
				IndexDomain: (t,ps);
				Definition: {
					tech_use(t,ps)<=cap2act(t)*techStock(t,ps)
					+sum[h, deltaW_UP(h,t,ps)]*(1-phs_Losses(t)) !Pumped hydro storage allows for a higher discharge
				}
			}
			Constraint emission_target {
				IndexDomain: (n,ps);
				Property: ShadowPrice;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[tb, tech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=n)*(activityPer_tech(tb) in activities_target)]
					!The forced constraint
					<=emissionTarget(n,ps)
				}
			}
			Constraint emission_targetCum {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,ps), tech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=ni)*(activityPer_tech(tb) in activities_target)*period_weightUSE(ps)*transition_interval]
					!The forced constraint
					<=emissionTarget_cum(ni)
				}
			}
			Constraint storageCO2_cumulative {
				IndexDomain: ni;
				Definition: {
					!The sum of the use of all the CO2 stored in each node
					sum[(tb,ps), tech_use(tb,ps)*(tech_subsector(tb)="CCUS Storage")*period_weightUSE(ps)*transition_interval]
					!The forced constraint
					<=cumulative_CO2storage(ni)
				}
			}
		}
		DeclarationSection Transition_description {
			Set transition_type {
				Definition: {
					{'Sequential','Simultaneous'}
				}
			}
			ElementParameter transition_selection {
				Range: transition_type;
			}
			Set periods_solve {
				SubsetOf: periods;
				Index: ps, ips, jps;
				Property: ElementsAreLabels;
			}
			Set periods_aux {
				SubsetOf: periods_solve;
				Index: pa;
				Property: ElementsAreNumerical;
				Definition: periods_solve;
			}
			Set actInv_ramp {
				SubsetOf: activities_solve;
				Index: ar, iar, jar;
				Definition: {
					{as | actChange_max(as)>0}
				}
			}
			Set techInv_ramp {
				SubsetOf: technologies;
				Index: tr, itr, jtr;
				Definition: {
					{t | techChange_max(t)>0}
				}
			}
			Set tech_maxConstraint {
				SubsetOf: technologies;
				Index: tmc, itmc, jtmc;
				Definition: {
					{t | techStock_bin(t)=1}
				}
			}
			Parameter period_weightSTAIR {
				IndexDomain: pss;
				Definition: {
					if (pss=last(periods_selection)) then
						10/(val(last(periods_selection))-val(first(periods_selection))+10) !To weight for the inertia of the system after the last period considering 10 years
					else
						(val(pss+1)-val(pss))/(val(last(periods_selection))-val(first(periods_selection))+10) !To weight for the length of the period
					endif
				}
			}
			Parameter period_weightINTRP {
				IndexDomain: pss;
				Definition: {
					if (pss=last(periods_selection)) then
						(10+(val(pss)-val(pss-1))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For the last period
					elseif (pss=first(periods_selection)) then
						((val(pss+1)-val(pss))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For the first period
					else
						((val(pss+1)-val(pss-1))/2)/(val(last(periods_selection))-val(first(periods_selection))+last_period_length) !For all intermediate periods
					endif
				}
			}
			Parameter period_weightUSE {
				IndexDomain: pss;
			}
			Parameter period_span {
				IndexDomain: pss;
				Definition: {
					if (pss=first(periods_selection)) then
						(val(pss)-2015)/5 !Hardcoded for 5 year time intervals
					else
						(val(pss)-val(pss-1))/5 !Hardcoded for 5 year time intervals
					endif
				}
			}
			Parameter inv_cost {
				IndexDomain: (t,p);
			}
			Parameter retro_cost {
				IndexDomain: (it,jt);
			}
			Parameter decom_frac {
				IndexDomain: t;
			}
			Parameter fom_cost {
				IndexDomain: (t,p);
			}
			Parameter WACC {
				IndexDomain: t;
			}
			Parameter social_discount_rate {
				Range: [0, 1];
			}
			Parameter base_year {
				Range: {
					{1990..2100}
				}
			}
			Parameter social_discount_factor {
				IndexDomain: pss;
				Definition: (1+social_discount_rate)^(base_year-(val(pss)));
			}
			Parameter construction_time {
				IndexDomain: t;
			}
			Parameter ec_lifetime {
				IndexDomain: t;
			}
			Parameter CRF {
				IndexDomain: t;
				Definition: {
					[(1-(1+WACC(t))^(-1))/(1-(1+WACC(t))^(-ec_lifetime(t)))]*(1+WACC(t))^(0.5)
					!First element is CRF with discounting to beginning of year, followed by correction for mid-year discounting. Based on TIMES Documentation Part II, Section 6.2.12
					
					!WACC(t)/[1-((1+WACC(t))^(-construction_time(t)-ec_lifetime(t)))] Second version - now replaced with mid-year discounting by Kira
					!depreciation_rate(t)/(1-(1+depreciation_rate(t))^(-tec_lifetime(t))) Original - then construction time added. Corrected in v4.3 by Kira
				}
			}
			Parameter tec_lifetime {
				IndexDomain: t;
			}
			Parameter decomMat_NewInv {
				IndexDomain: (t,pa,ps);
				Definition: {
					(ps>(pa+tec_lifetime(t)))*(ps>=pa) !Years of the selection for which the period value is larger than the investment year (pa) plus the lifetime of the technology
					-(ps-1>(pa+tec_lifetime(t)))*(ps>=pa) !Subsequent years of the selection for which the period value is larger than the investment year (pa) plus the lifetime of the technology
				}
				Comment: {
					"This matrix is a parameter.
					Here we are identifying the year in which technologies will be decommisioned accordingly with their lifetime and the year in which investment occurs."
				}
			}
			Parameter retrofit_relations {
				IndexDomain: (it,jt);
			}
			Parameter actChange_maxOrig {
				IndexDomain: ao;
			}
			Parameter actChange_max {
				IndexDomain: as;
				Definition: {
					actChange_maxOrig(as)+sum[iao | groupOf_activities(as,iao)=1, actChange_maxOrig(iao)*activities_netVolumesOrig(iao,2020)]/
					(sum[iao | groupOf_activities(as,iao)=1, activities_netVolumesOrig(iao,2020)] + 1e-20)
				}
			}
			Parameter techChange_max {
				IndexDomain: t;
			}
			Parameter techStock_exist {
				IndexDomain: t;
			}
			Parameter decom_planned {
				IndexDomain: (t,p);
			}
			Parameter decom_plannedSel {
				IndexDomain: (t,ps);
				Definition: sum[ip | ps-1<ip<=ps,decom_planned(t,ip)];
				Comment: {
					"!Convert the decommisioning years from database terms to the solving selection terms 
					(i.e. identify in which years of the solution the planned decommisioning should be considered)
					For instance, it might be the case that the database specifies that decommisioning of exisiting stock will occur in 2025,
					but that we are solving for the set of 2020, 2030, 2040, and 2050. Then the planned decommisioning in the solution should
					be considered to determine the 2030 stock."
				}
			}
			Parameter techStock_bin {
				IndexDomain: t;
				Range: binary;
			}
			Parameter techStock_min {
				IndexDomain: (t,p);
			}
			Parameter techStock_max {
				IndexDomain: (t,p);
			}
			Parameter no_eco_decom {
				IndexDomain: (t,p);
				Range: binary;
			}
			Parameter no_new_invest {
				IndexDomain: (t,p);
				Range: binary;
			}
			Variable cap_investments {
				IndexDomain: (t,ps);
				Range: nonnegative;
			}
			Variable retrofitting {
				IndexDomain: (it,jt,ps);
				Range: nonnegative;
			}
			Variable eco_decommisioning {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Comment: "This refers to cummulative advanced decommisioning triggered by economical cost-effectiveness";
			}
			Variable decomStock {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Definition: {
					if(transition_selection='Simultaneous') then
						decomStock(t,ps-1) !Decommisioning from previous period (CUMMULATIVE) AS VARIABLE
						+decom_plannedSel(t,ps) !Planned decommisioning of original stock (EVENT)
						+sum[pa, decomMat_NewInv(t,pa,ps)*(cap_investments(t,pa)+sum[it, retrofitting(it,t,pa)])] !Planned decommisioning of new added stock (EVENT)
						+eco_decommisioning(t,ps) !Premature decommisioning (EVENT)
					elseif(transition_selection='Sequential') then
						sum[ipss | ipss+1=ps, PdecomStock(t,ipss)] !Decommisioning from previous period (CUMMULATIVE) AS PARAMETER
						+decom_plannedSel(t,ps) !Planned decommisioning of original stock (EVENT)
						+sum[pa, decomMat_NewInv(t,pa,ps)*(cap_investments(t,pa)+sum[it, retrofitting(it,t,pa)])] !Planned decommisioning of new added stock (EVENT) VARIABLE
						+sum[pa | pa<ps, decomMat_NewInv(t,pa,ps)*(Pcap_investments(t,pa)+sum[it, Pretrofitting(it,t,pa)])] !Planned decommisioning of new added stock (EVENT) PARAMETER
						+eco_decommisioning(t,ps)-sum[ipss | ipss+1=ps, Peco_decommisioning(t,ipss)] !Change in advanced decommisioning (EVENT as it is the change in eco_decommisioning which is cummulative)
					endif
				}
				Comment: {
					"!Cummulative"
				}
			}
			Variable techStock {
				IndexDomain: (t,ps);
				Range: nonnegative;
				Definition: {
					if(ps=element(periods_selection,1)) then 
						techStock_exist(t) !stocks at the beggining of the year(CUMMULATIVE)
						+cap_investments(t,ps) !new investments (EVENT)
						+sum[it, retrofitting(it,t,ps)] !retrofitted aditions (EVENT)
						-sum[it, retrofitting(t,it,ps)] !retrofitted substractions (EVENT)
						-(decomStock(t,ps)-decomStock(t,ps-1)) !decommisioning in the year (EVENT as it is the difference of the cummulative)
					else
						if(transition_selection='Simultaneous') then
							techStock(t,ps-1) !use the stocks that are being used as variable
						else !if(transition_selection='Sequential') then
							sum[ipss | ipss+1=ps, PtechStock(t,ipss)] !use the stocks that are stored as parameter
						endif	
						+cap_investments(t,ps) !new investments (EVENT)
						+sum[it, retrofitting(it,t,ps)] !retrofitted aditions (EVENT)
						-sum[it, retrofitting(t,it,ps)] !retrofitted substractions (EVENT)
						-(decomStock(t,ps)-decomStock(t,ps-1)) !decommisioning in the year (EVENT as it is the difference of the cummulative)
					endif
				}
				Comment: {
					"!Cummulative"
				}
			}
			Constraint actStock_constraints {
				IndexDomain: (av,ps);
				Definition: sum[t | activityPer_tech(t)=av, techStock(t,ps)*cap2act(t)+sum[h, deltaS_shed(h,t,ps)]]=activities_netVolumes(av,ps);
			}
			Constraint minStock_constraints {
				IndexDomain: (t,ps);
				Definition: techStock(t,ps)>=techStock_min(t,ps);
			}
			Constraint maxStock_constraints {
				IndexDomain: (t,ps);
				Definition: techStock(t,ps)<=techStock_max(t,ps);
			}
			Constraint actInv_constraints {
				IndexDomain: (ar,ps);
				Definition: sum[t | activityPer_tech(t)=ar, cap_investments(t,ps)*cap2act(t)+sum[h, deltaS_shed(h,t,ps)]]<=activities_netVolumes(ar,ps)*actChange_max(ar)*period_span(ps)/100;
			}
			Constraint techInv_constraints {
				IndexDomain: (tr,ps);
				Definition: cap_investments(tr,ps)<=techChange_max(tr)*period_span(ps);
			}
			Constraint retrofit_constraint {
				IndexDomain: (it,jt,ps);
				Definition: {
					if(ps=element(periods_selection,1)) then
						retrofitting(it,jt,ps)<=retrofit_relations(it,jt)*techStock_exist(it)
					else
						if(transition_selection='Simultaneous') then
							retrofitting(it,jt,ps)<=retrofit_relations(it,jt)*techStock(it,ps-1)
						else !if(transition_selection='Sequential') then
							retrofitting(it,jt,ps)<=retrofit_relations(it,jt)*sum[ipss | ipss+1=ps, PtechStock(it,ipss)]
						endif
					
					endif
				}
			}
			Constraint decom_constraint {
				IndexDomain: (t,ps);
				Definition: {
					if(transition_selection='Simultaneous') then
						decomStock(t,ps)>=decomStock(t,ps-1)*(1-no_eco_decom(t,ps))
					else !if(transition_selection='Sequential') then
						decomStock(t,ps)>=sum[ipss | ipss+1=ps, PdecomStock(t,ipss)]*(1-no_eco_decom(t,ps))
					endif
				}
			}
			Constraint limit_new_invest {
				Definition: sum[(t,ps)|no_new_invest(t,ps)=1,cap_investments(t,ps)]=0;
			}
		}
		DeclarationSection Hourly_description {
			Set process_type {
				Index: yh;
			}
			Set profile_typeRead {
				SubsetOf: set_of_everything;
			}
			Set profile_type {
				SubsetOf: set_of_everything;
				Index: yp;
				Definition: profile_typeRead+activities_indirect;
			}
			Set activities_hour {
				SubsetOf: activities_solve;
				Index: ah, iah;
				Definition: {
					{as | dispatchType_act(as)='hourly'} + {as | dispatchType_act(as)='hourly-interconnected'}
				}
			}
			Set activities_indirect {
				SubsetOf: activities_solve;
				Index: ap, iap;
				Definition: {
					{as | dispatchType_act(as)='hourly-indirect'}
				}
			}
			Set activities_interconnected {
				SubsetOf: activities_hour;
				Index: ain, iain, jain;
				Definition: {
					{ah | dispatchType_act(ah)='hourly-interconnected'}
				}
			}
			Set tech_Operation {
				SubsetOf: tech_balancers;
				Index: tp;
				Definition: {
					{t |processType_tech(t)='Operation'} !The ones that are marked as so in the database
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-XC_TransmissionLoss)} !The cross border interconnection within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-HVtoMV_TransformerLoss)} !The transformers within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-MVtoLV_TransformerLoss)} !The transformers within the grouped network
					+{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-HVtoLV_TransformerLoss)} !The transformers within the grouped network
				}
			}
			Set tech_hourlyDispatch {
				SubsetOf: tech_balancers;
				Index: th, ith;
				Definition: {
					{t |processType_tech(t)='Hourly dispatch'} !The ones that are marked as so in the database
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-XC_TransmissionLoss)} !The cross border interconnection within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-HVtoMV_TransformerLoss)} !The transformers within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-MVtoLV_TransformerLoss)} !The transformers within the grouped network
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=-HVtoLV_TransformerLoss)} !The transformers within the grouped network
				}
			}
			Set tech_hourlyReport {
				SubsetOf: tech_balancers;
				Index: thh, ithh, jthh;
				Definition: {
					{th}+{tw}
				}
			}
			Set tech_rampDispatch {
				SubsetOf: tech_hourlyDispatch;
				Index: thr;
				Definition: {
					{t | ramping(t)>0}
				}
			}
			Set tech_hourlyInterconnection {
				SubsetOf: tech_hourlyDispatch;
				Index: thin, ithin, jthin;
				Definition: {
					{th | tech_subsector(th)="Inland generation"}
				}
			}
			ElementParameter processType_tech {
				IndexDomain: tb;
				Range: process_type;
			}
			ElementParameter profileType_techRead {
				IndexDomain: tb;
				Range: profile_type;
			}
			ElementParameter profileType_tech {
				IndexDomain: tb;
				Range: profile_type;
				Definition: {
					if (activityPer_tech(tb) in activities_indirect) then
						activityPer_tech(tb)
					elseif (CHP_prod(tb) in activities_indirect) then
						CHP_prod(tb)
					else
						profileType_techRead(tb)
					endif
				}
			}
			Parameter ramping {
				IndexDomain: tb;
			}
			Parameter hourly_profilesRead {
				IndexDomain: (h,yp);
				Definition: sum[ho, hourly_profilesReadOrig(ho,yp)*(hoursPer_hourOrig(ho)=h)];
			}
			Parameter hourly_profilesReadOrig {
				IndexDomain: (ho,yp);
			}
			Parameter hourly_profiles {
				IndexDomain: (h,yp);
				Definition: {
					if (yp in activities_indirect) then
						sum[itb | activity_balances(itb,yp,'2020')<0, hourly_profilesRead(h,profileType_techRead(itb))*activity_balances(itb,yp,'2020')]
						/sum[itb | activity_balances(itb,yp,'2020')<0, activity_balances(itb,yp,'2020')]
					else
						hourly_profilesRead(h,yp)
					endif
				}
			}
			Parameter interconnected_prices {
				IndexDomain: (h,ain,p);
				Definition: sum[ho, interconnected_pricesOrig(ho,ain,p)*(hoursPer_hourOrig(ho)=h)]/(24/hoursPer_day);
			}
			Parameter interconnected_pricesOrig {
				IndexDomain: (ho,ain,p);
			}
			Parameter vom_hourly {
				IndexDomain: (h,thin,p);
				Definition: interconnected_prices(h,activityPer_techOrig(thin),p);
			}
			Parameter baseload_treshold {
				InitialData: 0.05;
			}
			Parameter shedding_inLoad {
				Range: binary;
				InitialData: 0;
			}
			Variable tech_useHourly {
				IndexDomain: (h,thh,ps);
				Range: nonnegative;
			}
			Constraint balance_activitiesHourly {
				IndexDomain: (h,ah,ps);
				Definition: {
					sum[th, tech_useHourly(h,th,ps)*activity_balances(th,ah,ps)]+ !Hourly dispatch units
					sum[tw, tech_useHourly(h,tw,ps)*activity_balances(tw,ah,ps)-deltaW_UP(h,tw,ps)*dW_hourly(tw,ah)]+ !Water Reservoirs
					sum[td, tech_useDaily(dayPer_hour(h),td,ps)*activity_balances(td,ah,ps)/hoursPer_day]+ !Daily dispatch units (asssuming flat hourly consumption of electricity)
					!sum[tg, (deltaB_DW(dayPer_hour(h),tg,ps)-deltaB_UP(dayPer_hour(h),tg,ps))*activity_balances(tg,ah,ps)/24]+ !Gas buffers consumption (asssuming flat hourly consumption of electricity)
					sum[tp, tech_use(tp,ps)*hourly_profiles(h,profileType_tech(tp))*activity_balances(tp,ah,ps)]+ !Operation of non dispatchable technologies
					sum[tf, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps))*dQ_hourly(tf,ah)]+ !Demand respond of flexible technologies
					sum[tk, (tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))*activity_balances(tk,ah,ps)]+ !Operation of flexible CHPs
					sum[ts, (tech_use(ts,ps)*hourly_profiles(h,profileType_tech(ts))+deltaS_shed(h,ts,ps))*activity_balances(ts,ah,ps)]+ !Shedded use of technologies
					sum[tk, deltaP_CHP(h,tk,ps)*dP_electricity(tk,ah)] !Flexibility in Power/Heat range of CHP output
					=0
				}
			}
			Constraint balance_yearlyhourly {
				IndexDomain: (th,ps);
				Definition: tech_use(th,ps)=sum[h,tech_useHourly(h,th,ps)];
			}
			Constraint capacity_techHourly {
				IndexDomain: (h,th,ps);
				Definition: tech_useHourly(h,th,ps)<=techStock(th,ps)*cap2act(th)*hourly_profiles(h,profileType_tech(th));
			}
			Constraint rampingUP_techHourly {
				IndexDomain: (h,thr,ps);
				Definition: {
					tech_useHourly(h,thr,ps)-tech_useHourly(h-1,thr,ps)*(h<>1)-tech_useHourly(card(hours),thr,ps)*(h=1)<=
					techStock(thr,ps)*cap2act(thr)*hourly_profiles(h,profileType_tech(thr))*ramping(thr)
				}
			}
			Constraint rampingDW_techHourly {
				IndexDomain: (h,thr,ps);
				Definition: {
					tech_useHourly(h,thr,ps)-tech_useHourly(h-1,thr,ps)*(h<>1)-tech_useHourly(card(hours),thr,ps)*(h=1)>=
					-techStock(thr,ps)*cap2act(thr)*hourly_profiles(h,profileType_tech(thr))*ramping(thr)
				}
			}
		}
		DeclarationSection Daily_description {
			Set activities_day {
				SubsetOf: activities_solve;
				Index: ad;
				Definition: {
					{as | dispatchType_act(as)='daily'}
				}
			}
			Set tech_dailyDispatch {
				SubsetOf: tech_balancers;
				Index: td, itd;
				Definition: {
					{t |processType_tech(t)='Daily dispatch'} !The ones that are marked as so in the database
					-{t | (ord(activityPer_tech(t),activities_group)<>0)*(activity_balances(t,activityPer_tech(t),'2020')=0)} !The intergrid compressors that cancel each other due to grouping
				}
			}
			Set tech_gasBuffer {
				SubsetOf: tech_balancers;
				Index: tg, itg;
				Definition: {
					{t |processType_tech(t)='Gas buffer'}
				}
			}
			ElementParameter buffer_activityOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter buffer_activity {
				IndexDomain: tb;
				Range: activities_day;
				Definition: actSolvePer_actOrig(buffer_activityOrig(tb));
			}
			Parameter dB_daily {
				IndexDomain: (tg,ad);
				Definition: buffer_activity(tg)=ad;
			}
			Parameter bufferUP_capacity {
				IndexDomain: tb;
			}
			Parameter bufferDW_capacity {
				IndexDomain: tb;
			}
			Parameter buffer_storage {
				IndexDomain: tb;
			}
			Variable tech_useDaily {
				IndexDomain: (d,td,ps);
				Range: nonnegative;
			}
			Variable deltaB_UP {
				IndexDomain: (d,tg,ps);
				Range: nonpositive;
			}
			Variable deltaB_DW {
				IndexDomain: (d,tg,ps);
				Range: nonnegative;
			}
			Variable deltaB_S {
				IndexDomain: (d,tg,ps);
				Range: nonpositive;
				Definition: {
					if (d=1) then
						deltaB_S(365,tg,ps)+deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)
					else
						deltaB_S(d-1,tg,ps)+deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)
					endif
				}
			}
			Constraint balance_activitiesDaily {
				IndexDomain: (d,ad,ps);
				Definition: {
					sum[th, sum[ih | dayPer_hour(ih)=d, tech_useHourly(ih,th,ps)*activity_balances(th,ad,ps)]]+ !Hourly dispatch units
					sum[td, tech_useDaily(d,td,ps)*activity_balances(td,ad,ps)]+ !Daily dispatch units
					sum[tg, (deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps))*dB_daily(tg,ad)]+ !Daily buffer units
					!sum[tg, (deltaB_DW(d,tg,ps)-deltaB_UP(d,tg,ps))*activity_balances(tg,ad,ps)]+ !Gas buffers consumption 
					sum[tp, sum[ih | dayPer_hour(ih)=d, tech_use(tp,ps)*hourly_profiles(ih,profileType_tech(tp))*activity_balances(tp,ad,ps)]]+ !Operation of non dispatchable technologies
					sum[tk, sum[ih | dayPer_hour(ih)=d, (tech_use(tk,ps)*hourly_profiles(ih,profileType_tech(tk))+deltaU_CHP(ih,tk,ps))*activity_balances(tk,ad,ps)]]+ !Operation of flexible CHPs
					sum[ts, sum[ih | dayPer_hour(ih)=d, (tech_use(ts,ps)*hourly_profiles(ih,profileType_tech(ts))+deltaS_shed(ih,ts,ps))*activity_balances(ts,ad,ps)]] !Operation of shedding technologies
					=0
				}
			}
			Constraint balance_yearlyDaily {
				IndexDomain: (td,ps);
				Definition: tech_use(td,ps)=sum[d,tech_useDaily(d,td,ps)];
			}
			Constraint capacity_techDaily {
				IndexDomain: (d,td,ps);
				Definition: tech_useDaily(d,td,ps)<=techStock(td,ps)*cap2act(td)*sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(td))];
			}
			Constraint balanceY_dB {
				IndexDomain: (tg,ps);
				Definition: sum[d, deltaB_UP(d,tg,ps)+deltaB_DW(d,tg,ps)]=0;
			}
			Constraint capacityUP_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_UP(d,tg,ps)>=-bufferUP_capacity(tg)*techStock(tg,ps);
			}
			Constraint capacityDW_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_DW(d,tg,ps)<=bufferDW_capacity(tg)*techStock(tg,ps);
			}
			Constraint cummulativeS_dB {
				IndexDomain: (d,tg,ps);
				Definition: deltaB_S(d,tg,ps)>=-techStock(tg,ps)*buffer_storage(tg)*bufferDW_capacity(tg);
			}
		}
		DeclarationSection CHPs_descritpion {
			Set tech_hourlyCHPflex {
				SubsetOf: tech_balancers;
				Index: tk;
				Definition: {
					{t |processType_tech(t)='CHP flexible'}
				}
			}
			Set tech_hourlyCHPflexH {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_h;
				Definition: {
					{tk | CHP_range(tk)='1 hour [h]'}
				}
			}
			Set tech_hourlyCHPflexD {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_d;
				Definition: {
					{tk | CHP_range(tk)='1 day [d]'}
				}
			}
			Set tech_hourlyCHPflexW {
				SubsetOf: tech_hourlyCHPflex;
				Index: tk_w;
				Definition: {
					{tk | CHP_range(tk)='1 week [w]'}
				}
			}
			ElementParameter CHP_prodOrig {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter CHP_prod {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(CHP_prodOrig(tb));
			}
			ElementParameter CHP_fuelOrig {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter CHP_fuel {
				IndexDomain: tb;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(CHP_fuelOrig(tb));
			}
			ElementParameter CHP_range {
				IndexDomain: tb;
				Range: range_type;
			}
			Parameter CHP_eps {
				IndexDomain: (tk,p);
				Definition: {
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,p)]/
					(-activity_balances(tk,CHP_fuel(tk),p)-activity_balances(tk,CHP_prod(tk),p)/CHP_eta(tk))
				}
			}
			Parameter CHP_eta {
				IndexDomain: tb;
			}
			Parameter CHPdev_use {
				IndexDomain: tb;
			}
			Parameter CHPdev_PtoH {
				IndexDomain: tb;
			}
			Parameter dP_electricity {
				IndexDomain: (tk,ah);
				Definition: (activity_balances(tk,ah,'2020')>0)*(labelPer_act(ah)='Electricity');
			}
			Parameter dP_heat {
				IndexDomain: (tk,as);
				Definition: as=CHP_prod(tk);
			}
			Variable deltaU_CHP {
				IndexDomain: (h,tk,ps);
				Range: free;
			}
			Variable deltaP_CHP {
				IndexDomain: (h,tk,ps);
				Range: free;
			}
			Constraint balanceH_deltaHchp {
				IndexDomain: (h,tk_h,ps);
				Definition: {
					!sum(H2h)=sum(H0h)
					(tech_use(tk_h,ps)*hourly_profiles(h,profileType_tech(tk_h))+deltaU_CHP(h,tk_h,ps))
					*activity_balances(tk_h,CHP_prod(tk_h),ps) !H1 due to dU
					-CHP_eta(tk_h)*deltaP_CHP(h,tk_h,ps)/CHP_eps(tk_h,ps)= !dH from H1 to H2 due to dP
					(tech_use(tk_h,ps)*hourly_profiles(h,profileType_tech(tk_h)))
					*activity_balances(tk_h,CHP_prod(tk_h),ps) !H0
				}
			}
			Constraint balanceD_deltaHchp {
				IndexDomain: (d,tk_d,ps);
				Definition: {
					!sum(H1h)
					!sum[ih | 24*d>=ih>24*(d-1),
					!(tech_use(tk,ps)*hourly_profiles(ih,profileType_tech(tk))+deltaU_CHP(ih,tk,ps))*activity_balances(tk,CHPprod_tech(tk),ps)]=
					
					!sum(H2h)=sum(H0h)
					sum[ih | dayPer_hour(ih)=d,
					(tech_use(tk_d,ps)*hourly_profiles(ih,profileType_tech(tk_d))+deltaU_CHP(ih,tk_d,ps))*activity_balances(tk_d,CHP_prod(tk_d),ps) !H1 due to dU
					-CHP_eta(tk_d)*deltaP_CHP(ih,tk_d,ps)/CHP_eps(tk_d,ps)]= !dH from H1 to H2 due to dP
					sum[ih | dayPer_hour(ih)=d,
					(tech_use(tk_d,ps)*hourly_profiles(ih,profileType_tech(tk_d)))*activity_balances(tk_d,CHP_prod(tk_d),ps)]
				}
			}
			Constraint balanceW_deltaHchp {
				IndexDomain: (w,tk_w,ps);
				Definition: {
					!sum(H2h)=sum(H0h)
					sum[ih | weekPer_hour(ih)=w,
					(tech_use(tk_w,ps)*hourly_profiles(ih,profileType_tech(tk_w))+deltaU_CHP(ih,tk_w,ps))*activity_balances(tk_w,CHP_prod(tk_w),ps) !H1 due to dU
					-CHP_eta(tk_w)*deltaP_CHP(ih,tk_w,ps)/CHP_eps(tk_w,ps)]= !dH from H1 to H2 due to dP
					sum[ih | weekPer_hour(ih)=w,
					(tech_use(tk_w,ps)*hourly_profiles(ih,profileType_tech(tk_w)))*activity_balances(tk_w,CHP_prod(tk_w),ps)]
				}
			}
			Constraint capacityUP_deltaUchp {
				IndexDomain: (h,tk,ps);
				Definition: deltaU_CHP(h,tk,ps)<=tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))*CHPdev_use(tk);
			}
			Constraint capacityDW_deltaUchp {
				IndexDomain: (h,tk,ps);
				Definition: deltaU_CHP(h,tk,ps)>=-tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))*CHPdev_use(tk);
			}
			Constraint capacityUP_deltaPchp {
				IndexDomain: (h,tk,ps);
				Definition: {
					deltaP_CHP(h,tk,ps)<=
					(tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))* !Use after dU, U1
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,ps)]*CHPdev_PtoH(tk)
				}
			}
			Constraint capacityDW_deltaPchp {
				IndexDomain: (h,tk,ps);
				Definition: {
					deltaP_CHP(h,tk,ps)>=
					-(tech_use(tk,ps)*hourly_profiles(h,profileType_tech(tk))+deltaU_CHP(h,tk,ps))* !Use after dU, U1
					sum[iah | dP_electricity(tk,iah)=1, activity_balances(tk,iah,ps)]*CHPdev_PtoH(tk)
				}
			}
		}
		DeclarationSection Flex_description {
			Set flexibility_type {
				Index: yf;
			}
			Set tech_shedding {
				SubsetOf: tech_balancers;
				Index: ts;
				Definition: {
					{t |processType_tech(t)='Shedding'}
				}
			}
			Set tech_shedH {
				SubsetOf: tech_shedding;
				Index: ts_h;
				Definition: {
					{ts | shed_range(ts)='1 hour [h]'}
				}
			}
			Set tech_shedW {
				SubsetOf: tech_shedding;
				Index: ts_w;
				Definition: {
					{ts | shed_range(ts)='1 week [w]'}
				}
			}
			Set tech_reservoir {
				SubsetOf: tech_balancers;
				Index: tw, itw, jtw;
				Definition: {
					{t |processType_tech(t)='Water Reservoir'}
				}
			}
			Set tech_flexible {
				SubsetOf: tech_balancers;
				Index: tf;
				Definition: {
					{tb |flexibilityType_tech(tb)<>'none'}
				}
			}
			Set tech_flexLT {
				SubsetOf: tech_flexible;
				Index: tfl;
				Definition: {
					{tf |flexibilityType_tech(tf)<>'BE shifting'}
				}
				Comment: {
					"!Built Environment shifting in short term following sequential rules (i.e. you cannot reschedule load of the past in the future)"
				}
			}
			Set tech_fDRshifting {
				SubsetOf: tech_flexible;
				Index: tfs;
				Definition: {
					{tf |flexibilityType_tech(tf)='DR shifting'}
				}
			}
			Set tech_fBEshifting {
				SubsetOf: tech_flexible;
				Index: tfe;
				Definition: {
					{tf |flexibilityType_tech(tf)='BE shifting'}
				}
				Comment: {
					"!Built Environment shifting in short term following sequential rules (i.e. you cannot reschedule load of the past in the future)"
				}
			}
			Set tech_fStorage {
				SubsetOf: tech_flexible;
				Index: tfb;
				Definition: {
					{tf |flexibilityType_tech(tf)='Storage'}
				}
			}
			Set tech_fEV {
				SubsetOf: tech_flexible;
				Index: tfv;
				Definition: {
					{tf |flexibilityType_tech(tf)='EV smart charge'} + {tf |flexibilityType_tech(tf)='EV P-to-Grid'}
				}
			}
			Set tech_fEVcharging {
				SubsetOf: tech_fEV;
				Index: tfvc;
				Definition: {
					{tfv |flexibilityType_tech(tfv)='EV smart charge'}
				}
			}
			Set tech_fEVgrid {
				SubsetOf: tech_fEV;
				Index: tfvg;
				Definition: {
					{tfv |flexibilityType_tech(tfv)='EV P-to-Grid'}
				}
			}
			Set tech_fWithBattery {
				SubsetOf: tech_flexible;
				Index: tfwb;
				Definition: tech_fStorage+tech_fEV;
			}
			Set tech_flexD {
				SubsetOf: tech_flexible;
				Index: tf_d;
				Definition: {
					{tf | flex_range(tf)='1 day [d]'}
				}
			}
			Set tech_flexR {
				SubsetOf: tech_flexible;
				Index: tf_r;
				Definition: {
					{tf | flex_range(tf)='3 days [r]'}
				}
			}
			Set tech_flexW {
				SubsetOf: tech_flexible;
				Index: tf_w;
				Definition: {
					{tf | flex_range(tf)='1 week [w]'}
				}
			}
			Set tech_flexM {
				SubsetOf: tech_flexible;
				Index: tf_m;
				Definition: {
					{tf | flex_range(tf)='1 month [m]'}
				}
			}
			Set tech_flexS {
				SubsetOf: tech_flexible;
				Index: tf_s;
				Definition: {
					{tf | flex_range(tf)='1 season [s]'}
				}
			}
			Set tech_flexB {
				SubsetOf: tech_flexible;
				Index: tf_b;
				Definition: {
					{tf | flex_range(tf)='6 months [b]'}
				}
			}
			Set tech_flexY {
				SubsetOf: tech_flexible;
				Index: tf_y;
				Definition: {
					{tf | flex_range(tf)='1 year [y]'}
				}
			}
			ElementParameter flexibilityType_tech {
				IndexDomain: tb;
				Range: flexibility_type;
			}
			ElementParameter shed_range {
				IndexDomain: tb;
				Range: range_type;
			}
			ElementParameter hybrid_substitute {
				IndexDomain: tb;
				Range: activities_solve;
			}
			ElementParameter flex_activityOrig {
				IndexDomain: tb;
				Range: activities_original;
			}
			ElementParameter flex_activity {
				IndexDomain: tb;
				Range: activities_hour;
				Definition: actSolvePer_actOrig(flex_activityOrig(tb));
			}
			ElementParameter flex_range {
				IndexDomain: tb;
				Range: range_type;
			}
			ElementParameter profileType_EVuse {
				IndexDomain: tfv;
				Range: profile_type;
				Definition: {
					StringToElement(profile_type,profileType_tech(tfv)+" - Use",0);
				}
			}
			Parameter dQ_hourly {
				IndexDomain: (tf,ah);
				Definition: flex_activity(tf)=ah;
			}
			Parameter dS_hourly {
				IndexDomain: (ts,ah);
				Definition: activity_balances(ts,ah,'2020')<0;
			}
			Parameter dW_hourly {
				IndexDomain: (tw,ah);
				Definition: activity_balances(tw,ah,'2020')=1;
			}
			Parameter shed_capacity {
				IndexDomain: tb;
			}
			Parameter shed_volume {
				IndexDomain: tb;
			}
			Parameter phs_capacity {
				IndexDomain: tb;
			}
			Parameter phs_storage {
				IndexDomain: tb;
			}
			Parameter phs_losses {
				IndexDomain: tb;
			}
			Parameter hybrid_ratio {
				IndexDomain: tb;
			}
			Parameter flex_capacity {
				IndexDomain: tb;
			}
			Parameter flex_storage {
				IndexDomain: tb;
			}
			Parameter flex_losses {
				IndexDomain: tb;
			}
			Parameter flex_nnLoad {
				IndexDomain: tb;
			}
			Parameter avg_journey {
				IndexDomain: tb;
			}
			Parameter avg_speed {
				IndexDomain: tb;
			}
			Variable deltaQ_UP {
				IndexDomain: (h,tf,ps);
				Range: nonpositive;
				Comment: {
					"!Be aware that DQ refere to change in the demand of the energy carrier, which implies a negative simbol in the balance. A negative value of DQ corresponds to an increase in the demand."
				}
			}
			Variable deltaQ_DW {
				IndexDomain: (h,tf,ps);
				Range: nonnegative;
			}
			Variable deltaQ_S {
				IndexDomain: (h,tfwb,ps);
				Range: nonpositive;
				Definition: {
					if (h=1) then
						deltaQ_S(card(hours),tfwb,ps)+deltaQ_UP(h,tfwb,ps)*(1-flex_Losses(tfwb))+deltaQ_DW(h,tfwb,ps)
					else
						deltaQ_S(h-1,tfwb,ps)+deltaQ_UP(h,tfwb,ps)*(1-flex_Losses(tfwb))+deltaQ_DW(h,tfwb,ps)
					endif
				}
			}
			Variable deltaQd_UP {
				IndexDomain: (d,tfl,ps);
				Range: nonpositive;
				Definition: sum[ih | dayPer_hour(ih)=d, deltaQ_UP(ih,tfl,ps)];
			}
			Variable deltaQd_DW {
				IndexDomain: (d,tfl,ps);
				Range: nonnegative;
				Definition: sum[ih | dayPer_hour(ih)=d, deltaQ_DW(ih,tfl,ps)];
			}
			Variable deltaS_shed {
				IndexDomain: (h,ts,ps);
				Range: nonpositive;
			}
			Variable deltaW_UP {
				IndexDomain: (h,tw,ps);
				Range: nonnegative;
			}
			Variable deltaW_S {
				IndexDomain: (h,tw,ps);
				Range: nonnegative;
				Definition: {
					if (h=1) then
						deltaW_S(card(hours),tw,ps)						!Previous hour reserve
						+deltaW_UP(h,tw,ps)*(1-phs_Losses(tw))					!Pumped energy
						+techStock(tw,ps)*cap2act(tw)*hourly_profiles(h,profileType_tech(tw))	!Natural inflow to the reservoir
						-tech_useHourly(h,tw,ps)						!Discharged energy
					else
						deltaW_S(h-1,tw,ps)							!Previous hour reserve
						+deltaW_UP(h,tw,ps)*(1-phs_Losses(tw))					!Pumped energy
						+techStock(tw,ps)*cap2act(tw)*hourly_profiles(h,profileType_tech(tw))	!Natural inflow to the reservoir
						-tech_useHourly(h,tw,ps)						!Discharged energy
					endif
				}
			}
			Constraint balanceH_deltaS {
				IndexDomain: (h,ts_h,ps);
				Definition: deltaS_shed(h,ts_h,ps)>=-tech_use(ts_h,ps)*shed_volume(ts_h)*hourly_profiles(h,profileType_tech(ts_h));
			}
			Constraint balanceW_deltaS {
				IndexDomain: (w,ts_w,ps);
				Definition: {
					sum[ih | weekPer_hour(ih)=w, deltaS_shed(ih,ts_w,ps)]>=
					-tech_use(ts_w,ps)*shed_volume(ts_w)*sum[ih | weekPer_hour(ih)=w, hourly_profiles(ih,profileType_tech(ts_w))]
				}
			}
			Constraint capacity_deltaS {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps)>=techStock(ts,ps)*shed_capacity(ts)*(24/hoursPer_day)/sum[iah | dS_hourly(ts,iah)=1, activity_balances(ts,iah,ps)];
			}
			Constraint sufficiency_deltaS {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps)>=-tech_use(ts,ps)*hourly_profiles(h,profileType_tech(ts));
			}
			Constraint balanceQ_deltaQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | hoursPer_quarter*(q+flex_range(tfe)-1)>=ih>hoursPer_quarter*(q-1), deltaQ_UP(ih,tfe,ps)+deltaQ_DW(ih,tfe,ps)*(1-flex_losses(tfe))]=0
					sum[ih | quarterPer_hour(ih)=q, deltaQ_UP(ih,tfe,ps)+deltaQ_DW(ih,tfe,ps)/(1-flex_losses(tfe))]=0
				}
			}
			Constraint balanceD_deltaQd {
				IndexDomain: (d,tf_d,ps);
				Definition: deltaQd_UP(d,tf_d,ps)+deltaQd_DW(d,tf_d,ps)/(1-flex_losses(tf_d))=0;
			}
			Constraint balanceR_deltaQd {
				IndexDomain: (r,tf_r,ps);
				Definition: sum[id | rangePer_day(id)=r, deltaQd_UP(id,tf_r,ps)+deltaQd_DW(id,tf_r,ps)/(1-flex_losses(tf_r))]=0;
			}
			Constraint balanceW_deltaQd {
				IndexDomain: (r,tf_w,ps);
				Definition: sum[id | weekPer_day(id)=r, deltaQd_UP(id,tf_w,ps)+deltaQd_DW(id,tf_w,ps)/(1-flex_losses(tf_w))]=0;
			}
			Constraint balanceM_deltaQd {
				IndexDomain: (m,tf_m,ps);
				Definition: sum[id | monthPer_day(id)=m, deltaQd_UP(id,tf_m,ps)+deltaQd_DW(id,tf_m,ps)/(1-flex_losses(tf_m))]=0;
			}
			Constraint balanceS_deltaQd {
				IndexDomain: (s,tf_s,ps);
				Definition: sum[id | seasonPer_day(id)=s, deltaQd_UP(id,tf_s,ps)+deltaQd_DW(id,tf_s,ps)/(1-flex_losses(tf_s))]=0;
			}
			Constraint balanceB_deltaQd {
				IndexDomain: (b,tf_b,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_UP(ih,tfs,ps)+deltaQ_DW(ih,tfs,ps)*(1-flex_losses(tfs))]=0
					sum[id | semesterPer_day(id)=b, deltaQd_UP(id,tf_b,ps)+deltaQd_DW(id,tf_b,ps)/(1-flex_losses(tf_b))]=0
				}
			}
			Constraint balanceY_deltaQd {
				IndexDomain: (tf_y,ps);
				Definition: sum[d, deltaQd_UP(d,tf_y,ps)+deltaQd_DW(d,tf_y,ps)/(1-flex_losses(tf_y))]=0;
			}
			Constraint capacityUP_dQtfe {
				IndexDomain: (h,tfe,ps);
				Definition: deltaQ_UP(h,tfe,ps)>=-(flex_capacity(tfe)*(24/hoursPer_day)*techStock(tfe,ps)+hourly_profiles(h,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps))*flex_nnLoad(tfe);
				Comment: {
					"!Here we don\'t use (1-flex_nnLoad because we don\'t want to roast people in their homes this nnLoad stands for the operation band-wide"
				}
			}
			Constraint capacityUP_dQtfs {
				IndexDomain: (h,tfs,ps);
				Definition: {
					!deltaQ_UP(h,tfs,ps)>=-(flex_capacities(tfs)+hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps))*tech_use(tfs,ps)*flex_comfort(tfs)
					deltaQ_UP(h,tfs,ps)>=-(flex_capacity(tfs)*(24/hoursPer_day)*techStock(tfs,ps)+hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps))!*(1-flex_nnLoad(tfs))
				}
			}
			Constraint capacityUP_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_UP(h,tfb,ps)>=-techStock(tfb,ps)*flex_capacity(tfb)*(24/hoursPer_day);
			}
			Constraint capacityUP_dQtfv {
				IndexDomain: (h,tfv,ps);
				Definition: {
					deltaQ_UP(h,tfv,ps)>=
					-(flex_capacity(tfv)*(24/hoursPer_day)*(
					techStock(tfv,ps)
					-tech_use(tfv,ps)*hourly_profiles(h,profileType_EVuse(tfv))/(avg_speed(tfv))*(24/hoursPer_day))
					+tech_use(tfv,ps)*activity_balances(tfv,flex_activity(tfv),ps)*hourly_profiles(h,profileType_tech(tfv)))
				}
			}
			Constraint capacityUP_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					deltaW_UP(h,tw,ps)<=techStock(tw,ps)*phs_capacity(tw)*hourly_profiles(h,'Flat')*GWtoPJ_y !(HARDCODED)
				}
			}
			Constraint capacityDW_dQtfe {
				IndexDomain: (h,tfe,ps);
				Definition: deltaQ_DW(h,tfe,ps)<=-hourly_profiles(h,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)*(1-flex_nnLoad(tfe));
			}
			Constraint capacityDW_dQtfs {
				IndexDomain: (h,tfs,ps);
				Definition: deltaQ_DW(h,tfs,ps)<=-hourly_profiles(h,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)*(1-flex_nnLoad(tfs));
			}
			Constraint capacityDW_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_DW(h,tfb,ps)<=techStock(tfb,ps)*flex_capacity(tfb)*(24/hoursPer_day);
				Comment: {
					"!Assuming symetrical (dis)charging"
				}
			}
			Constraint capacityDW_dQtfvc {
				IndexDomain: (h,tfvc,ps);
				Definition: deltaQ_DW(h,tfvc,ps)<=-tech_use(tfvc,ps)*activity_balances(tfvc,flex_activity(tfvc),ps)*hourly_profiles(h,profileType_tech(tfvc))*(1-flex_nnLoad(tfvc));
			}
			Constraint capacityDW_dQtfvg {
				IndexDomain: (h,tfvg,ps);
				Definition: {
					deltaQ_DW(h,tfvg,ps)<=flex_capacity(tfvg)*(24/hoursPer_day)*(techStock(tfvg,ps)
					-tech_use(tfvg,ps)*hourly_profiles(h,profileType_EVuse(tfvg))/(avg_speed(tfvg)*(24/hoursPer_day)))
				}
			}
			Constraint capacityDW_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					tech_useHourly(h,tw,ps)<=techStock(tw,ps)*hourly_profiles(h,'Flat')*GWtoPJ_y !(HARDCODED)
				}
			}
			Constraint cumulativeUP_dQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | 6*q>=ih>6*(q-1), deltaQ_UP(ih,tfe,ps)] >=
					!sum[ih | 6*(q+flex_range(tfe))>=ih>6*(q-1)+1, hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,'Electricity',ps)*tech_use(tfe,ps)*flex_comfort(tfe)]
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), deltaQ_UP(ih,tfe,ps)] >=
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1)+1, hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)]
				}
			}
			Constraint cumulativeUP_dQtfs {
				IndexDomain: (d,tfs,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_UP(ih,tfs,ps)] >=
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps)*tech_use(tfs,ps)*flex_comfort(tfs)*flex_range(tfs)]
					sum[ih | dayPer_hour(ih)=d, deltaQ_UP(ih,tfs,ps)] >=
					sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)]
				}
			}
			Constraint cumulativeDW_dQtfs {
				IndexDomain: (d,tfs,ps);
				Definition: {
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), deltaQ_DW(ih,tfs,ps)] <=
					!sum[ih | 24*(d+flex_range(tfs)-1)>=ih>24*(d-1), -hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,'Electricity',ps)*tech_use(tfs,ps)*flex_comfort(tfs)*flex_range(tfs)]
					sum[ih | dayPer_hour(ih)=d, deltaQ_DW(ih,tfs,ps)] <=
					sum[ih | dayPer_hour(ih)=d, -hourly_profiles(ih,profileType_tech(tfs))*activity_balances(tfs,flex_activity(tfs),ps)*tech_use(tfs,ps)]
				}
			}
			Constraint cumulativeDW_dQtfe {
				IndexDomain: (q,tfe,ps);
				Definition: {
					!sum[ih | 6*q>=ih>6*(q-1), deltaQ_DW(ih,tfe,ps)] <=
					!sum[ih | 6*q>=ih>6*(q-1), -hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,'Electricity',ps)*tech_use(tfe,ps)*flex_comfort(tfe)]
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), deltaQ_DW(ih,tfe,ps)] <=
					sum[ih | hoursPer_quarter*q>=ih>hoursPer_quarter*(q-1), -hourly_profiles(ih,profileType_tech(tfe))*activity_balances(tfe,flex_activity(tfe),ps)*tech_use(tfe,ps)]
				}
			}
			Constraint cumulativeS_dQtfb {
				IndexDomain: (h,tfb,ps);
				Definition: deltaQ_S(h,tfb,ps)>=-techStock(tfb,ps)*flex_storage(tfb)*flex_capacity(tfb);
			}
			Constraint cumulativeS_dQtfv {
				IndexDomain: (h,tfv,ps);
				Definition: {
					deltaQ_S(h,tfv,ps)>=-
					(flex_storage(tfv)*flex_capacity(tfv)*(techStock(tfv,ps)-tech_use(tfv,ps)*hourly_profiles(h,profileType_EVuse(tfv))/(avg_speed(tfv)*(24/hoursPer_day)))
					+tech_use(tfv,ps)*activity_balances(tfv,flex_activity(tfv),ps)
					*sum[ih | (h<ih<=h+avg_journey(tfv)/hoursPer_Day) + (h>=card(h)+1-avg_journey(tfv)/hoursPer_Day)*(1<=ih<h-card(h)+avg_journey(tfv)/hoursPer_Day),
					hourly_profiles(ih,profileType_EVuse(tfv))])
				}
			}
			Constraint cumulativeS_dW {
				IndexDomain: (h,tw,ps);
				Definition: {
					deltaW_S(h,tw,ps)<=techStock(tw,ps)*phs_storage(tw)*GWhtoPJ !(HARDCODED)
				}
			}
			Constraint nonPos_Shed {
				IndexDomain: (h,ts,ps);
				Definition: deltaS_shed(h,ts,ps)<=0;
			}
		}
		DeclarationSection Infra_description {
			Set tech_infra {
				SubsetOf: technologies;
				Index: ti, iti;
			}
			Set tech_infraH {
				SubsetOf: tech_infra;
				Index: ti_h, iti_h;
				Definition: {
					{ti | infra_range(ti)='1 hour [h]'}
				}
			}
			Set tech_infraD {
				SubsetOf: tech_infra;
				Index: ti_d, iti_d;
				Definition: {
					{ti | infra_range(ti)='1 day [d]'}
				}
			}
			Set act_infraH {
				SubsetOf: activities_solve;
				Index: ai_h;
			}
			Set act_infraD {
				SubsetOf: activities_solve;
				Index: ai_d;
			}
			ElementParameter infra_activityOrig {
				IndexDomain: ti;
				Range: activities_original;
			}
			ElementParameter infra_activity {
				IndexDomain: ti;
				Range: activities_solve;
				Definition: actSolvePer_actOrig(infra_activityOrig(ti));
			}
			ElementParameter infra_range {
				IndexDomain: ti;
				Range: range_type;
			}
			ElementParameter nodePer_techInfra {
				IndexDomain: ti;
				Range: nodes;
				Definition: nodePer_act(infra_activity(ti));
			}
			Constraint infraVol_H {
				IndexDomain: (h,ai_h,ps);
				Definition: {
					sum[itb | activity_balances(itb,ai_h,ps)<0, activity_balances(itb,ai_h,ps)*(
					tech_useHourly(h,itb,ps) !Hourly dispatch units
					+tech_useDaily(dayPer_hour(h),itb,ps)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
					!+(deltaB_DW(dayPer_hour(h),itb,ps)-deltaB_UP(dayPer_hour(h),itb,ps))/24 !Gas buffers consumption (asssuming flat hourly consumption of electricity)
					+tech_use(itb,ps)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
					+deltaS_shed(h,itb,ps))] !Shedding
					+sum[tf, (deltaQ_UP(h,tf,ps)+deltaQ_DW(h,tf,ps)*(1-(tf in tech_fStorage)))*dQ_hourly(tf,ai_h)] !Upwards response of flexible technologies
					>=
					-sum[iti_h | infra_activity(iti_h)=ai_h, techStock(iti_h,ps)*cap2act(iti_h)*24/hoursPer_day] !Maximum available rate at which infrastructure capacity allows to perform an activity [UoA/UoR]
				}
				Comment: {
					"! Hourly activities\' infrastructure are constrained by consumption only. This, as all the activities that require 
					hourly constraints are also balanced hourly (i.e. S_h=D_h)"
				}
			}
			Constraint infraVol_D {
				IndexDomain: (d,ai_d,ps);
				Definition: {
					sum[itb | activity_balances(itb,ai_d,ps)<0, activity_balances(itb,ai_d,ps)* !Only account for the demand
					(tech_useDaily(d,itb,ps) !Daily dispatch units
					!+deltaB_DW(d,itb,ps)-deltaB_UP(d,itb,ps) !Gas buffers consumption 
					+sum[ih | dayPer_hour(ih)=d, tech_useHourly(ih,itb,ps) !Hourly dispatch units
					+hourly_profiles(ih,profileType_tech(itb))*
					(tech_use(itb,ps) !Operation of non dispatchable technologies
					+deltaU_CHP(ih,itb,ps) !Operation of flexible CHPs
					+deltaS_shed(ih,itb,ps))])] !Operation of shedding technologies
					+sum[tg, deltaB_UP(d,tg,ps)*dB_daily(tg,ai_d)] !Daily buffer units
					>=
					-sum[iti_d | infra_activity(iti_d)=ai_d, techStock(iti_d,ps)*cap2act(iti_d)] !Maximum available rate at which infrastructure capacity allows to perform an activity [UoA/UoR]
				}
			}
		}
	}
	Section Optimization_section {
		Procedure CheckMemoryMPs {
			Body: {
				for IndexGeneratedMathematicalPrograms do
					MemoryUseMPs(IndexGeneratedMathematicalPrograms) := GMP::Instance::GetMemoryUsed(IndexGeneratedMathematicalPrograms);
					endfor;
			}
		}
		DeclarationSection Optimization_declaration {
			Set periods_selection {
				SubsetOf: periods;
				Index: pss, ipss;
				Property: ElementsAreLabels;
				OrderBy: pss;
				InitialData: {
					{2020,2030}
				}
			}
			Set activeVariables_planning {
				SubsetOf: AllVariables;
				Definition: {
					data 
					    { tech_use           , cap_investments    , retrofitting       , eco_decommisioning , decomStock         , techStock          ,
					      tech_useHourly     , tech_useDaily      , deltaB_UP          , deltaB_DW          , deltaB_S           , deltaU_CHP         ,
					      deltaP_CHP         , deltaQ_UP          , deltaQ_DW          , deltaQ_S           , deltaQd_UP         , deltaQd_DW         ,
					      deltaS_shed        , deltaW_UP          , deltaW_S           , totalCosts_planning }
				}
			}
			Set activeVariables_operation {
				SubsetOf: AllVariables;
				Definition: {
					data 
					    { tech_use            , tech_useHourly      , tech_useDaily       , deltaB_UP           , deltaB_DW           ,
					      deltaB_S            , deltaU_CHP          , deltaP_CHP          , deltaQ_UP           , deltaQ_DW           ,
					      deltaQ_S            , deltaQd_UP          , deltaQd_DW          , deltaS_shed         , deltaW_UP           ,
					      deltaW_S            , totalCosts_operation }
				}
			}
			Set activeConstraints_planning {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { balance_activities       , balance_activitiesFix    , balance_activitiesmatconv, capacity_technologies    ,
					      emission_target          , emission_targetCum       , storageCO2_cumulative    , decomStock               ,
					      techStock                , actStock_constraints     , minStock_constraints     , maxStock_constraints     ,
					      actInv_constraints       , techInv_constraints      , retrofit_constraint      , decom_constraint         ,
					      limit_new_invest         , balance_activitiesHourly , balance_yearlyhourly     , capacity_techHourly      ,
					      rampingUP_techHourly     , rampingDW_techHourly     , deltaB_S                 , balance_activitiesDaily  ,
					      balance_yearlyDaily      , capacity_techDaily       , balanceY_dB              , capacityUP_dB            ,
					      capacityDW_dB            , cummulativeS_dB          , balanceH_deltaHchp       , balanceD_deltaHchp       ,
					      balanceW_deltaHchp       , capacityUP_deltaUchp     , capacityDW_deltaUchp     , capacityUP_deltaPchp     ,
					      capacityDW_deltaPchp     , deltaQ_S                 , deltaQd_UP               , deltaQd_DW               ,
					      deltaW_S                 , balanceH_deltaS          , balanceW_deltaS          , capacity_deltaS          ,
					      sufficiency_deltaS       , balanceQ_deltaQtfe       , balanceD_deltaQd         , balanceR_deltaQd         ,
					      balanceW_deltaQd         , balanceM_deltaQd         , balanceS_deltaQd         , balanceB_deltaQd         ,
					      balanceY_deltaQd         , capacityUP_dQtfe         , capacityUP_dQtfs         , capacityUP_dQtfb         ,
					      capacityUP_dQtfv         , capacityUP_dW            , capacityDW_dQtfe         , capacityDW_dQtfs         ,
					      capacityDW_dQtfb         , capacityDW_dQtfvc        , capacityDW_dQtfvg        , capacityDW_dW            ,
					      nonPos_Shed              , infraVol_H               , infraVol_D               , totalCosts_planning      }
				}
			}
			Set activeConstraints_operation {
				SubsetOf: AllConstraints;
				Definition: {
					data 
					    { balance_activities      , balance_activitiesFix   , capacity_technologies   , emission_target         ,
					      emission_targetCum      , storageCO2_cumulative   , balance_activitiesHourly, balance_yearlyhourly    ,
					      capacity_techHourly     , rampingUP_techHourly    , rampingDW_techHourly    , deltaB_S                ,
					      balance_activitiesDaily , balance_yearlyDaily     , capacity_techDaily      , balanceY_dB             ,
					      capacityUP_dB           , capacityDW_dB           , cummulativeS_dB         , balanceH_deltaHchp      ,
					      balanceD_deltaHchp      , balanceW_deltaHchp      , capacityUP_deltaUchp    , capacityDW_deltaUchp    ,
					      capacityUP_deltaPchp    , capacityDW_deltaPchp    , deltaQ_S                , deltaQd_UP              ,
					      deltaQd_DW              , deltaW_S                , balanceH_deltaS         , balanceW_deltaS         ,
					      capacity_deltaS         , sufficiency_deltaS      , balanceQ_deltaQtfe      , balanceD_deltaQd        ,
					      balanceR_deltaQd        , balanceW_deltaQd        , balanceM_deltaQd        , balanceS_deltaQd        ,
					      balanceB_deltaQd        , balanceY_deltaQd        , capacityUP_dQtfe        , capacityUP_dQtfs        ,
					      capacityUP_dQtfb        , capacityUP_dQtfv        , capacityUP_dW           , capacityDW_dQtfe        ,
					      capacityDW_dQtfs        , capacityDW_dQtfb        , capacityDW_dQtfvc       , capacityDW_dQtfvg       ,
					      capacityDW_dW           , nonPos_Shed             , infraVol_H              , infraVol_D              ,
					      totalCosts_operation    }
				}
			}
			Variable totalCosts_planning {
				Range: free;
				Definition: {
					!Objective function, revised from previous versions
						sum[ps, 
						social_discount_factor(ps)*							!social discount rate assigns weights to different periods
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*					!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t))]				!New investments
					
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*(
							sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input). Epsilon set to 0 to save memory, can be removed later if not needed.
							)]
							!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
					
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Variable totalCosts_operation {
				Range: free;
				Definition: {
					sum[ps, (
						sum[t, tech_use(t,ps)*vom_cost(t,ps)] !Variable costs (including fuel costs)
						+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+p_epsilon)]!Electricity costs of interconnected nodes
						+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
						!+0.000001*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
						!+0.000001*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
						)*social_discount_factor(ps)]
				}
			}
			MathematicalProgram LeastCostPlanning {
				Objective: totalCosts_planning;
				Direction: minimize;
				Constraints: activeConstraints_planning;
				Variables: activeVariables_planning;
				Type: LP;
			}
			MathematicalProgram LeastCostOperation {
				Objective: totalCosts_operation;
				Direction: minimize;
				Constraints: activeConstraints_operation;
				Variables: activeVariables_operation;
				Type: Automatic;
			}
			Parameter p_epsilon {
				Definition: 0;
			}
			Parameter PtotalCosts_planning {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weightUSE(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+p_epsilon)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Parameter capCosts_planning {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weightUSE(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
						)
					]
				}
			}
			Parameter fomCosts_planning {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weightUSE(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
					
						)
					]
				}
			}
			Parameter vomCosts_planning {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						period_weightUSE(ps)*modelled_transition_interval*					!Accounts for the fact that only single years of costs are included rather than totals. Period weight defines share of period in total interval, transition interval is the length of the scenario time horizon
						(
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Parameter PtotalCosts_planning_single {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Parameter capCosts_planning_single {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						(
							! CAPEX
							+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
							(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New investments
							+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t) 	!Salvage value at end of lifetime (temporarily removed, should be modelled with the possibility to consider a positive cost, a zero, or a "negative" cost representing recovered value)
							)]
					
						)
					]
				}
			}
			Parameter fomCosts_planning_single {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						(
							! FOM
							+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fixed costs
					
						)
					]
				}
			}
			Parameter vomCosts_planning_single {
				Definition: {
						sum[ps, 
						social_discount_factor(ps)*
						(
					
							! VOM
							+sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
							+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-6)]!Electricity costs of interconnected nodes
							+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*vom_cost(t,ps)] !Deviations in tech use due to flexibility
							!Misc
							+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
							+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
					
						)
					]
				}
			}
			Parameter MemoryUseMPs {
				IndexDomain: IndexGeneratedMathematicalPrograms;
			}
		}
		DeclarationSection GMP_formulation {
			ElementParameter FinishedSS {
				Range: AllSolverSessions;
			}
			ElementParameter GMP_planning {
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter GMP_operation {
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter presGMP_planning {
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter presGMP_operation {
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter Session_GMP {
				IndexDomain: pss;
				Range: AllSolverSessions;
			}
			StringParameter GMP_selection;
		}
		DeclarationSection Mathematical_Program_Details {
			Quantity SI_Time_Duration {
				BaseUnit: s;
				Conversions: minute->s : #-># * 60;
				Comment: "Expresses the value for the duration of periods.";
			}
			Set FixedTunningOptions {
				SubsetOf: AllOptions;
			}
			Set MathProgramDetails {
				Index: mps;
				Definition: {
					{
					'Solver',
					'Type of the Mathematical Program',
					'Solution Energy Units',
					'Solution Money Units',
					'GMP',
					'Number of Constraints',
					'Number of Variables',
					'Number of Nonzeros',
					'Number of Iterations',
					'Generation Time',
					'Solving Time',
					'Elapsed Time',
					'Used Memory',
					'Peak Memory',
					'Objective Function Value',
					'Date of Run',
					'Solver Status',
					'Mathematical Program Status',
					'Intra-year Prices',
					'Total Run Time',
					'Database Version',
					'Model Version',
					'Hours per day'
					}
				}
			}
			Set run_number {
				SubsetOf: Integers;
				Index: rn, irn;
				Property: ElementsAreNumerical;
				Definition: {
					{h | h <= 100}
				}
			}
			ElementParameter run_numberState {
				Range: run_number;
			}
			ElementParameter ProgressWindow {
				Range: AllProgressCategories;
			}
			ElementParameter AY_GMP {
				IndexDomain: pss;
				Range: AllGeneratedMathematicalPrograms;
			}
			ElementParameter pres_AY_GMP {
				IndexDomain: pss;
				Range: AllGeneratedMathematicalPrograms;
			}
			Parameter ThreadLimiter;
			ElementParameter AY_SolverSession {
				IndexDomain: pss;
				Range: AllSolverSessions;
			}
			StringParameter MathProgramParameters {
				IndexDomain: (mps,rn);
			}
			StringParameter ReferenceTime;
			StringParameter ReferenceTime_IYP;
			StringParameter ReferenceTime_Generation;
		}
		DeclarationSection Solver_Settings_Declaration {
			StringParameter solver_selection {
				Definition: "GUROBI 9.0";
			}
			StringParameter StringCPU {
				Definition: {
					EnvironmentGetString("NUMBER_OF_PROCESSORS", StringCPU);
				}
			}
			Parameter NumCPU {
				Range: integer;
				Definition: {
					val(StringCPU);
				}
			}
			Parameter techStock_tolerance {
				InitialData: 1e-4;
			}
			Parameter Feasibility_tolerance {
				InitialData: 1e-7;
			}
			Parameter Optimality_tolerance {
				InitialData: 1e-7;
			}
			Parameter BarrierConvergence_tolerance {
				InitialData: 1e-7;
			}
		}
		Procedure TechStock_roundUP {
			Body: {
				!Get rid of negative stocks and maximum stocks
				techStock(t,pss):=max(techStock(t,pss),0);
				techStock(t,pss):=min(techStock(t,pss),techStock_max(t,pss));
				
				!!Option 1. Just add a bit of stock to all natinal technologies
				!techStock(tn,pss):=techStock(tn,pss)+(techStock(tn,pss)>0)*1e-7;
				
				
				!Option 2. Compute to ensure feasibilities
				!Check that the Stocks are sufficient to meet demand up to 1e-9
				
				!!Via the loop
				!for (ipss in periods_selection) do
				!	for (iad in activities_driver) do
				!		if (activityScope_act(iad)<>'External') then;
				!			if(sum[itb | activityPer_tech(itb)=iad, techStock(itb,ipss)*cap2act(itb)]<activities_netVolumes(iad,ipss)) then;
				!				techStock(tb,ipss):=techStock(tb,ipss)+
				!				(activityPer_tech(tb)=iad)*(techStock(tb,ipss)=max(itb | activityPer_tech(itb)=iad, techStock(itb,ipss)))
				!				*(activities_netVolumes(iad,ipss)-sum[jtb | activityPer_tech(jtb)=iad, techStock(jtb,ipss)*cap2act(jtb)])
				!				/cap2act(tb);
				!			endif;
				!		endif;
				!	endfor;
				!endfor;
				!
				!techStock(tn,pss):=techStock(tn,pss)+(activityType_act(activityPer_tech(tn))='Energy')*(techStock(tn,pss)>0)*1e-7;
				
				
				!Without loop
				techStock(t,pss):=techStock(t,pss)
				+(activityType_act(activityPer_tech(t))='Driver') !If technology meets a driver activity
				*(techStock(t,pss)=max[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)]) !If technology has the maximum stock of technologies meeting that activity
				*(sum[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)*cap2act(it)]<activities_netVolumes(activityPer_tech(t),pss)) !If the activity of that technology is violating the constraint... not necessary, but to prevent
				*(activities_netVolumes(activityPer_tech(t),pss)-sum[it | activityPer_tech(it)=activityPer_tech(t), techStock(it,pss)*cap2act(it)])/cap2act(t) !The necessary stock to make the constraint feasible
				+(activityType_act(activityPer_tech(t))='Energy')*((techStock_max(t,pss)-techStock(t,pss))>1e-7)*1e-7 !Add a bit of stock to energy technologies
				+(activityType_act(activityPer_tech(t))='Emission')*(techStock(t,pss)>0)*((techStock_max(t,pss)-techStock(t,pss))>=1e-8)*(techStock_max(t,pss)-techStock(t,pss)) !Add a bit of stock to emission technologies
				;
			}
		}
		Procedure GMP_details {
			Arguments: run_step,GMP_name,time_stamp;
			Body: {
				MathProgramParameters('Solver',run_step) := GMP::Instance::GetSolver(GMP_name);
				MathProgramParameters('Type of the Mathematical Program',run_step) := GMP::Instance::GetMathematicalProgrammingType(GMP_name) ;
				MathProgramParameters('Solution Energy Units',run_step) := "PJ" ;
				MathProgramParameters('Solution Money Units',run_step) := "M€" ;
				MathProgramParameters('Hours per day',run_step) := hoursPer_day;
				MathProgramParameters('GMP',run_step) := GMP_name ;
				MathProgramParameters('Number of Constraints',run_step) := GMP::Instance::GetNumberOfRows(GMP_name);
				MathProgramParameters('Number of Variables',run_step) := GMP::Instance::GetNumberOfColumns(GMP_name);
				MathProgramParameters('Number of Nonzeros',run_step) := GMP::Instance::GetNumberOfNonzeros(GMP_name);
				MathProgramParameters('Number of Iterations',run_step) := GMP::Solution::GetIterationsUsed(GMP_name,1);
				MathProgramParameters('Solving Time',run_step) := round(GMP::Solution::GetTimeUsed(GMP_name,1)/6000,1) + " [min]";
				MathProgramParameters('Elapsed Time',run_numberState) := round(CurrentToMoment([minute],time_stamp),1) + " [min]" ;
				MathProgramParameters('Used Memory',run_step) := round(MemoryInUse(),1) + " [MB]";
				MathProgramParameters('Peak Memory',run_step) := round(GMP::Solution::GetMemoryUsed(GMP_name,1),1) + " [MB]";
				MathProgramParameters('Objective Function Value',run_step) := round(GMP::Solution::GetObjective(GMP_name,1),2) + " [" + "M€" + "]";
				MathProgramParameters('Date of Run',run_numberState) := time_stamp;
				MathProgramParameters('Solver Status',run_step) := GMP::Solution::GetSolverStatus(GMP_name,1);
				MathProgramParameters('Intra-year Prices',run_step) := PricesValue + (PricesValue='yes')*(" by ") + (PricesValue='yes')*IntrayearValue;
				MathProgramParameters('Mathematical Program Status',run_step) := GMP::Solution::GetProgramStatus(GMP_name,1);
			}
			ElementParameter run_step {
				Range: run_number;
			}
			ElementParameter GMP_name {
				Range: AllGeneratedMathematicalPrograms;
			}
			StringParameter time_stamp;
		}
		Procedure DefineSolverSettings {
			Body: {
				!Procedure to define the required solver settings
				
				!Apply desired settings for the options regardless of the solver 
				option Presolve_feasibility_tolerance:= 1e-9;
				if (crossover_enabling = 'yes') then
					option Presolve_feasibility_tolerance:= 1e-6;
				endif;
				Feasibility_tolerance := 1e-6;
				Optimality_tolerance := 1e-6;
				barrierConvergence_tolerance := 1e-8;
				
				if (scaleValue='yes') then
					option scale_model:= 'On';
					option scaling_algorithm:= 'Iterative';
				elseif (scaleValue='no') then
					option scale_model:= 'Off';
				endif;
				
				!Apply desired settings for the each solver
				! For Gurobi 10.0
					option 'GUROBI 10.0'.Method := 'Barrier';
					option 'GUROBI 10.0'.Barrier_crossover := 'Off';
					option 'GUROBI 10.0'.Thread_limit := CPUCores;
					option 'GUROBI 10.0'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'GUROBI 10.0'.Barrier_homogeneous_algorithm := 'Automatic'; !'On'
					option 'GUROBI 10.0'.presolve := 'Automatic' ; !'Automatic'; !'Off'
					option 'GUROBI 10.0'.scale := 'Yes'; !'No'
					option 'GUROBI 10.0'.presolve_dual := 'Off';
					option 'GUROBI 10.0'.feasibility := Feasibility_tolerance;
					option 'GUROBI 10.0'.optimality := Optimality_tolerance;
					if (crossover_enabling = 'yes') then
						option 'GUROBI 10.0'.Barrier_crossover := 'Automatic';
						option 'GUROBI 10.0'.presolve_dual := 'Presolve primal and dual';
						if (RobustValue = 'yes') then
							option 'GUROBI 10.0'.Barrier_crossover_basis := 'Robust';
						elseif (RobustValue = 'no') then
							option 'GUROBI 10.0'.Barrier_crossover_basis := 'Fast';
						endif;	
					endif;
				
				! For Gurobi 9.5
					option 'GUROBI 9.5'.Method := 'Barrier';
					option 'GUROBI 9.5'.Barrier_crossover := 'Off';
					option 'GUROBI 9.5'.Thread_limit := CPUCores;
					option 'GUROBI 9.5'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'GUROBI 9.5'.Barrier_homogeneous_algorithm := 'Automatic'; !'On'
					option 'GUROBI 9.5'.presolve := 'Automatic' ; !'Automatic'; !'Off'
					option 'GUROBI 9.5'.scale := 'Yes'; !'No'
					option 'GUROBI 9.5'.presolve_dual := 'Off';
					option 'GUROBI 9.5'.feasibility := Feasibility_tolerance;
					option 'GUROBI 9.5'.optimality := Optimality_tolerance;
					if (crossover_enabling = 'yes') then
						option 'GUROBI 9.5'.Barrier_crossover := 'Automatic';
						option 'GUROBI 9.5'.presolve_dual := 'Presolve primal and dual';
						if (RobustValue = 'yes') then
							option 'GUROBI 9.5'.Barrier_crossover_basis := 'Robust';
						elseif (RobustValue = 'no') then
							option 'GUROBI 9.5'.Barrier_crossover_basis := 'Fast';
						endif;	
					endif;
				
				! For Gurobi 9.1
					option 'GUROBI 9.1'.Method := 'Barrier';
					option 'GUROBI 9.1'.Barrier_crossover := 'Off';
					option 'GUROBI 9.1'.Thread_limit := CPUCores;
					option 'GUROBI 9.1'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'GUROBI 9.1'.Barrier_homogeneous_algorithm := 'Automatic'; !'On'
					option 'GUROBI 9.1'.presolve := 'Automatic'; !'Off'
					option 'GUROBI 9.1'.scale := 'Yes'; !'No'
					option 'GUROBI 9.1'.presolve_dual := 'Off';
					option 'GUROBI 9.1'.feasibility := Feasibility_tolerance;
					option 'GUROBI 9.1'.optimality := Optimality_tolerance;
					if (crossover_enabling = 'yes') then
						option 'GUROBI 9.1'.Barrier_crossover := 'Automatic';
						option 'GUROBI 9.1'.presolve_dual := 'Presolve primal and dual';
						if (RobustValue = 'yes') then
							option 'GUROBI 9.1'.Barrier_crossover_basis := 'Robust';
						elseif (RobustValue = 'no') then
							option 'GUROBI 9.1'.Barrier_crossover_basis := 'Fast';
						endif;	
					endif;
				
				! For Gurobi 9.0
					option 'GUROBI 9.0'.Method := 'Barrier';
					option 'GUROBI 9.0'.Barrier_crossover := 'Off';
					option 'GUROBI 9.0'.Thread_limit := CPUCores;
					option 'GUROBI 9.0'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'GUROBI 9.0'.Barrier_homogeneous_algorithm := 'On';
					option 'GUROBI 9.0'.presolve := 'Off';
					option 'GUROBI 9.0'.scale := 'No';
					option 'GUROBI 9.0'.presolve_dual := 'Off';
					option 'GUROBI 9.0'.feasibility := Feasibility_tolerance;
					option 'GUROBI 9.0'.optimality := Optimality_tolerance;
					if (crossover_enabling = 'yes') then
						option 'GUROBI 9.0'.Barrier_crossover := 'Automatic';
						option 'GUROBI 9.0'.presolve_dual := 'Presolve primal and dual';
						if (RobustValue = 'yes') then
							option 'GUROBI 9.0'.Barrier_crossover_basis := 'Robust';
						elseif (RobustValue = 'no') then
							option 'GUROBI 9.0'.Barrier_crossover_basis := 'Fast';
						endif;	
					endif;
				
				! For Gurobi 8.1
					option 'GUROBI 8.1'.Method := 'Barrier';
					option 'GUROBI 8.1'.Barrier_crossover := 'Off';
					option 'GUROBI 8.1'.Thread_limit := CPUCores;
					option 'GUROBI 8.1'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'GUROBI 8.1'.presolve_dual := 'Off';
					option 'GUROBI 8.1'.feasibility := Feasibility_tolerance;
					option 'GUROBI 8.1'.optimality := Optimality_tolerance;
					if (crossover_enabling = 'yes') then
						option 'GUROBI 8.1'.Barrier_crossover := 'Automatic';
						option 'GUROBI 8.1'.presolve_dual := 'Presolve primal and dual';
						if (RobustValue = 'yes') then
							option 'GUROBI 8.1'.Barrier_crossover_basis := 'Robust';
						elseif (RobustValue = 'no') then
							option 'GUROBI 8.1'.Barrier_crossover_basis := 'Fast';
						endif;	
					endif;
				
				! For CPLEX 12.10
					option 'CPLEX 12.10'.LP_Method := 'Barrier';
					option 'CPLEX 12.10'.Barrier_progress_solution := 1;
					option 'CPLEX 12.10'.Solution_type := 'nonbasic';	
					option 'CPLEX 12.10'.Global_thread_limit := CPUCores;
					option 'CPLEX 12.10'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'CPLEX 12.10'.parallel_mode := 'Automatic';
					option 'CPLEX 12.10'.preprocessing_reduction_types := 'Both primal and dual reductions';
					!option 'CPLEX 12.10'.presolve_pass_dual := 'Off';
					if (crossover_enabling = 'yes') then
						option 'CPLEX 12.10'.Solution_type := 'basic';
						option 'CPLEX 12.10'.Barrier_crossover_algorithm := 'Automatic';
						option 'CPLEX 12.10'.presolve_pass_dual := 'On';
						option 'CPLEX 12.10'.preprocessing_reduction_types := 'Both primal and dual reductions';
					endif;	
				
				! For CPLEX 20.1
					option 'CPLEX 20.1'.LP_Method := 'Barrier';
					option 'CPLEX 20.1'.Barrier_progress_solution := 1;
					option 'CPLEX 20.1'.Solution_type := 'nonbasic';	
					option 'CPLEX 20.1'.Global_thread_limit := CPUCores;
					option 'CPLEX 20.1'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'CPLEX 20.1'.feasibility := Feasibility_tolerance;
					option 'CPLEX 20.1'.optimality := Optimality_tolerance;
					option 'CPLEX 20.1'.parallel_mode := 'Opportunistic';
				!	option 'CPLEX 20.1'.preprocessing_reduction_types := 'No primal and dual reductions';
				!	option 'CPLEX 20.1'.presolve_pass_dual := 'Off';
					if (crossover_enabling = 'yes') then
						option 'CPLEX 20.1'.Solution_type := 'basic';
						option 'CPLEX 20.1'.Barrier_crossover_algorithm := 'Automatic';
						option 'CPLEX 20.1'.presolve_pass_dual := 'On';
						option 'CPLEX 20.1'.preprocessing_reduction_types := 'Both primal and dual reductions';
					endif;
				
				
				! For CPLEX 22.1
					option 'CPLEX 22.1'.LP_Method := 'Barrier';
					option 'CPLEX 22.1'.Barrier_progress_solution := 1;
					option 'CPLEX 22.1'.Solution_type := 'nonbasic';	
					option 'CPLEX 22.1'.Global_thread_limit := CPUCores;
					option 'CPLEX 22.1'.Barrier_convergence_tolerance := BarrierConvergence_tolerance;
					option 'CPLEX 22.1'.feasibility := Feasibility_tolerance;
					option 'CPLEX 22.1'.optimality := Optimality_tolerance;
					option 'CPLEX 22.1'.parallel_mode := 'Opportunistic';
				!	option 'CPLEX 22.1'.preprocessing_reduction_types := 'No primal and dual reductions';
					option 'CPLEX 22.1'.presolve_pass_dual := 'Off';
					if (crossover_enabling = 'yes') then
						option 'CPLEX 22.1'.Solution_type := 'basic';
						option 'CPLEX 22.1'.Barrier_crossover_algorithm := 'Automatic';
						option 'CPLEX 22.1'.presolve_pass_dual := 'On';
						option 'CPLEX 22.1'.preprocessing_reduction_types := 'Both primal and dual reductions';
					endif;
				
				
				StatusMessage("Solver options were succesfully updated");
			}
		}
	}
	Section Post_Processing {
		DeclarationSection Variables_stored {
			Parameter Ptech_use {
				IndexDomain: (t,p);
			}
			Parameter Ptech_useNet {
				IndexDomain: (t,p);
				Definition: Ptech_use(t,p)+sum[h, PdeltaU_CHP(h,t,p)]+sum[h, PdeltaS_shed(h,t,p)];
			}
			Parameter Ptech_useHourly {
				IndexDomain: (h,t,p);
				InitialData: 0;
			}
			Parameter Ptech_useHourlyNet {
				IndexDomain: (h,t,p);
				Definition: {
					Ptech_useHourly(h,t,p)
					+Ptech_useDaily(dayPer_hour(h),t,p)/hoursPer_day
					+Ptech_use(t,p)*hourly_profiles(h,profileType_tech(t))*(((t in tech_hourlyDispatch)+(t in tech_dailyDispatch))=0)
					+PdeltaU_CHP(h,t,p)
					+PdeltaS_shed(h,t,p)
				}
			}
			Parameter Ptech_useDaily {
				IndexDomain: (d,t,p);
			}
			Parameter Ptech_useDailyNet {
				IndexDomain: (d,t,p);
				Definition: {
					sum[ih | dayPer_hour(ih)=d, Ptech_useHourly(ih,t,p)]
					+Ptech_useDaily(d,t,p)
					+sum[ih | dayPer_hour(ih)=d, Ptech_use(t,p)*hourly_profiles(ih,profileType_tech(t))]*(((t in tech_hourlyDispatch)+(t in tech_dailyDispatch))=0)
					+sum[ih | dayPer_hour(ih)=d, PdeltaU_CHP(ih,t,p)]
					+sum[ih | dayPer_hour(ih)=d, PdeltaS_shed(ih,t,p)]
				}
			}
			Parameter PdeltaQ_UP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQ_DW {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQ_S {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaQd_UP {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaQd_DW {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_UP {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_DW {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaB_S {
				IndexDomain: (d,t,p);
			}
			Parameter PdeltaU_CHP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaP_CHP {
				IndexDomain: (h,t,p);
			}
			Parameter PdeltaS_shed {
				IndexDomain: (h,t,p);
			}
			Parameter Pcap_investments {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter Pretrofitting {
				IndexDomain: (it,jt,p);
				InitialData: 0;
			}
			Parameter Peco_decommisioning {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter PdecomStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter PtechStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter StechStock {
				IndexDomain: (t,p);
				InitialData: 0;
			}
			Parameter Ptotal_costs;
			Parameter Pyearly_prices {
				IndexDomain: (as,p);
				InitialData: 0;
			}
			Parameter PCO2_prices {
				IndexDomain: (ac,p);
				InitialData: 0;
			}
		}
		DeclarationSection Shadow_Prices {
			Set activitiesHour_heat {
				SubsetOf: activities_hour;
				Index: ahh;
				Definition: {
					{ah | StringOccurrences(ah,"Heat")>0}
				}
			}
			Set activitiesHour_electricity {
				SubsetOf: activities_hour;
				Index: ahe, iahe;
				Definition: {
					{ah | StringOccurrences(ah,"Electricity")>0}
				}
			}
			Parameter hourly_prices {
				IndexDomain: (h,ah,p);
				InitialData: 0;
			}
			Parameter daily_prices {
				IndexDomain: (d,ad,p);
				InitialData: 0;
			}
			Parameter yearly_prices {
				IndexDomain: (as,p);
				InitialData: 0;
			}
			Parameter CO2_prices {
				IndexDomain: (ac,p);
				InitialData: 0;
			}
			Parameter CO2_price_single {
				IndexDomain: (n,p);
				InitialData: 0;
			}
			Parameter shadow_energyPrices {
				IndexDomain: (nn,ae,p);
				Definition: {
					if (ae in activities_year) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*yearly_prices(ae,p)]
					elseif (ae in activities_day) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*sum[d, daily_prices(d,ae,p)]/card(days)]
					elseif (ae in activities_hour) then
						sum[n, (namePer_node(nodePer_act(ae))=nn)*sum[h, hourly_prices(h,ae,p)]/card(hours)]
					endif
				}
			}
			Parameter shadow_CO2Prices {
				IndexDomain: (nn,ac,p);
				Definition: sum[n, (namePer_node(nodePer_act(ac))=nn)*CO2_prices(ac,p)];
			}
		}
		DeclarationSection Energy_Costs {
			Set typesOf_LCOEelements {
				Index: tol, itol, jtol;
				Definition: {
					{'CAPEX','FOM','VOC','Fuels','Emissions'}
				}
			}
			Set typesOf_LCOEmethod {
				Index: tolm, itolm, jtolm;
				Definition: {
					{'Theoretical','Real'}
				}
			}
			Set activities_secondary {
				SubsetOf: activities_solve;
				Index: ass, iass, jass;
				Definition: {
					{as | sum[(tb,pnz), (activityPer_tech(tb)=as)*Ptech_useNet(tb,pnz)]=0}
				}
			}
			Parameter TechExclussiveness {
				IndexDomain: (tb,p);
				Definition: {
					sum[as, activity_balances(tb,as,p)*(activityPer_tech(tb)=as)*(as in activities_emission=0)]
					/sum[as, activity_balances(tb,as,p)*(activity_balances(tb,as,p)*(as in activities_emission=0)>0)+1e-9]
				}
			}
			Parameter EnergyCosts_yearly {
				IndexDomain: (ae,p);
				InitialData: 0;
			}
			Parameter EnergyCosts_daily {
				IndexDomain: (d,ad,p);
				InitialData: 0;
			}
			Parameter EnergyCosts_hourly {
				IndexDomain: (h,ah,p);
				InitialData: 0;
			}
			Parameter EnergyCosts {
				IndexDomain: (h,ae,p);
				InitialData: 0;
			}
			Parameter FuelCosts {
				IndexDomain: (h,tb,p);
				Definition: -sum[ae, Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts(h,ae,p)*(activity_balances(tb,ae,p)<0)]*TechExclussiveness(tb,p);
			}
			Parameter EnergyCosts_mean {
				IndexDomain: (ae,p);
				Definition: sum[h, EnergyCosts(h,ae,p)]/card(hours);
			}
			Parameter EnergyCostsVariability {
				IndexDomain: (h,ae,p);
				Definition: {
					if (h=1) then
						EnergyCosts(h,ae,p)-EnergyCosts(card(hours),ae,p) !(HARDCODED)
					else
					EnergyCosts(h,ae,p)-EnergyCosts(h-1,ae,p)
					endif
				}
			}
			Parameter EmissionCosts {
				IndexDomain: (ac,p);
				Definition: sum[tb, (activityPer_tech(tb)=ac)*vom_cost(tb,p)];
			}
			Parameter techCosts_voc {
				IndexDomain: (h,tb,p);
				InitialData: 0;
			}
			Parameter IterCounter;
			Parameter LCOE_tech {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*inv_cost(tb,p)*CRF(tb)/(Ptech_useNet(tb,p)+1e-10)
						+IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*inv_cost(tb,p)*CRF(tb)/cap2act(tb)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*fom_cost(tb,p)/(Ptech_useNet(tb,p)+1e-10)
						+IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*fom_cost(tb,p)/cap2act(tb)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[h,FuelCosts(h,tb,p)]/(Ptech_useNet(tb,p)+1e-10)
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)<0.01)
						*sum[(ae), activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)*(activity_balances(tb,ae,p)<0)]
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE_theo {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*inv_cost(tb,p)*CRF(tb)/cap2act(tb)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*fom_cost(tb,p)/cap2act(tb)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ae), activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)*(activity_balances(tb,ae,p)<0)]
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE_real {
				IndexDomain: (nn,as,tb,tol,p);
				Definition: {
					if (tol='CAPEX') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*inv_cost(tb,p)*CRF(tb)/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='FOM') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*PtechStock(tb,p)*fom_cost(tb,p)/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='VOC') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*vom_cost(tb,p)
						)
					elseif (tol='Fuels') then
						(activityPer_tech(tb)=as)*(
						IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[h,FuelCosts(h,tb,p)]/(Ptech_useNet(tb,p)+1e-10)
						)
					elseif (tol='Emissions') then
						(activityPer_tech(tb)=as)*(
						-IEM_node(nodePer_techBal(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(Ptech_useNet(tb,p)>=0.01)
						*sum[(ac), activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
						)
					endif
				}
			}
			Parameter LCOE {
				IndexDomain: (nn,as,tb,tolm,tol,p);
				Definition: {
					if (tolm='Theoretical') then
						LCOE_theo(nn,as,tb,tol,p)
					elseif(tolm='Real') then
						LCOE_real(nn,as,tb,tol,p)
					endif
				}
			}
			Parameter EnergyCosts_node {
				IndexDomain: (nn,ae,p);
				Definition: (namePer_node(nodePer_act(ae))=nn)*EnergyCosts_mean(ae,p);
			}
			Parameter EnergyCosts_nodeH {
				IndexDomain: (nn,h,ah,p);
				Definition: (namePer_node(nodePer_act(ah))=nn)*EnergyCosts_hourly(h,ah,p);
			}
			Parameter EnergyCosts_nodeD {
				IndexDomain: (nn,d,ad,p);
				Definition: (namePer_node(nodePer_act(ad))=nn)*EnergyCosts_daily(d,ad,p);
			}
		}
		DeclarationSection System_Costs {
			Set typesOf_costs {
				Index: toc, itoc;
				Definition: {
					{'Capital Cost','Fixed Operational Cost','Variable Operational Cost','Fuel Costs','Emission Costs','Trading Costs','National Primary Energy Cost','Import Cost','Export Revenues','Total Cost'}
				}
			}
			Set typesOf_payments {
				Index: top, itop;
				Definition: {
					{'Investment', 'Decommisioning', 'Retrofitting','Operational', 'Variable'}
				}
			}
			Set typesOf_techSources {
				Index: tots, itots;
				Definition: {
					{'Balancing','Infrastructure'}
				}
			}
			Parameter objFun_decomposition {
				IndexDomain: (toc,p,ps);
				Definition: {
					if (toc='Capital Cost') then
						+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
						(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
						+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
						!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
						)] 	
					elseif (toc='Fixed Operational Cost') then
						sum[(t), techStock(t,p)*fom_cost(t,p)] !Fix costs
					elseif (toc='Variable Operational Cost') then
						sum[t, tech_use(t,p)*(vom_cost(t,p)+1e-6)] !Variable costs (including fuel costs)
						+sum[(h,thin), tech_useHourly(h,thin,p)*(vom_hourly(h,thin,p)+1e-6)]!Electricity costs of interconnected nodes
						+sum[(h,t), (deltaU_CHP(h,t,p)+deltaS_shed(h,t,p))*vom_cost(t,p)] !Deviations in tech use due to flexibility
					elseif (toc='Total Cost') then
						+sum[(t,jp), InvMat_lifeTime(t,jp,ps)*						!lifetime matrix
						(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
						+sum[(it,jt), retrofitting(it,jt,ps)*CRF(jt)*(retro_cost(it,jt)+p_epsilon)] !Retrofitting costs (based on Excel database input)
						!-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*annuity_fac(t)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
						)] 
						+sum[(t), techStock(t,p)*fom_cost(t,p)] !Fix costs
						+sum[t, tech_use(t,p)*(vom_cost(t,p)+1e-6)] !Variable costs (including fuel costs)
						+sum[(h,thin), tech_useHourly(h,thin,p)*(vom_hourly(h,thin,p)+1e-6)]!Electricity costs of interconnected nodes
						+sum[(h,t), (deltaU_CHP(h,t,p)+deltaS_shed(h,t,p))*vom_cost(t,p)] !Deviations in tech use due to flexibility
					endif
				}
			}
			Parameter InvMat_lifeTime {
				IndexDomain: (t,jp,p);
				Definition: (p<=jp+ec_lifetime(t))*(p>=jp);
			}
			Parameter capitalCosts_techBal {
				IndexDomain: (n,tb,p);
				Definition: {
					!sum[(pa,ip) | ip<=p, Pcap_investments(tn,ip)*InvMat_lifeTime(tn,pa,ip)*inv_cost(tn,pa)*annuity_fac(tn)]
					(nodePer_techBal(tb)=n)*(
					(techStock_exist(tb)-sum[jp | jp<=p, decom_planned(tb,jp)])*inv_cost(tb,'2020')*CRF(tb)	!Existing stock
					+sum[(jp), InvMat_lifeTime(tb,jp,p)*						!lifetime matrix
							(Pcap_investments(tb,jp)*inv_cost(tb,jp)*CRF(tb)				!New invetments
							+sum[(it), Pretrofitting(it,tb,jp)*CRF(tb)*(retro_cost(it,tb)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-Peco_decommisioning(tb,jp)*(1-decom_frac(tb))*inv_cost(tb,jp)*annuity_fac(tb)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
							)] 
							)
				}
			}
			Parameter capitalCosts_techInfra {
				IndexDomain: (n,ti,p);
				Definition: {
					!sum[(pa,ip) | ip<=p, Pcap_investments(tn,ip)*InvMat_lifeTime(tn,pa,ip)*inv_cost(tn,pa)*annuity_fac(tn)]
					(nodePer_techInfra(ti)=n)*(
					(techStock_exist(ti)-sum[jp | jp<=p, decom_planned(ti,jp)])*inv_cost(ti,'2020')*CRF(ti)	!Existing stock
					+sum[(jp), InvMat_lifeTime(ti,jp,p)*						!lifetime matrix
							(Pcap_investments(ti,jp)*inv_cost(ti,jp)*CRF(ti)				!New invetments
							+sum[(it), Pretrofitting(it,ti,jp)*CRF(ti)*(retro_cost(it,ti)+p_epsilon)] !Retrofitting costs (based on Excel database input)
							!-Peco_decommisioning(ti,jp)*(1-decom_frac(ti))*inv_cost(ti,jp)*CRF(ti)	!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
							)])
				}
			}
			Parameter fuelCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					sum[(h,ae), -Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts(h,ae,p)*(activity_balances(tb,ae,p)<0)]
				}
			}
			Parameter nationalPrimary_energyCost {
				IndexDomain: (n,tb,p);
				Definition: Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(1-(tb in tech_imports));
			}
			Parameter emissionCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					sum[(h,ac), -Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ac,p)*EmissionCosts(ac,p)]
				}
			}
			Parameter exportCosts_act {
				IndexDomain: (n,ae,p);
				Definition: {
					!Yearly activities
					(dispatchType_act(ae)='yearly')*final_activities(n,ae,p)*EnergyCosts_yearly(ae,p)
					
					!Daily activities
					-sum[(d,tb), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,tb), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter exportCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					!Yearly activities
					sum[ae, (dispatchType_act(ae)='yearly')*final_activities(n,ae,p)*EnergyCosts_yearly(ae,p)*EnergyShare_tech(n,ae,tb,p)]
					
					!Daily activities
					-sum[(d,ae), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,ae), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter importCosts_act {
				IndexDomain: (n,ae,p);
				Definition: {
					!Yearly activities
					sum[tb, (activityPer_tech(tb)=ae)*Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tb in tech_imports)]
					
					!Daily activities
					-sum[(d,tb), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,tb), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter importCosts_tech {
				IndexDomain: (n,tb,p);
				Definition: {
					!Yearly activities
					Ptech_useNet(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n)*(tb in tech_imports)
					
					!Daily activities
					-sum[(d,ae), (dispatchType_act(ae)='daily')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useDailyNet(d,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_daily(d,ae,p)]
					
					!Hourly activities
					-sum[(h,ae), (dispatchType_act(ae)='hourly')*(nodePer_techBal(tb)=n)*(nodePer_act(ae)<>n)*(activity_balances(tb,ae,p)<0) !Technologies that are taking energy from other nodes
					*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)*EnergyCosts_hourly(h,ae,p)]
				}
			}
			Parameter SystemCosts_techBal {
				IndexDomain: (n,toc,tb,p);
				Definition: {
					if (toc='Capital Cost') then
						capitalCosts_techBal(n,tb,p)*(nodePer_techBal(tb)=n)
					elseif (toc='Fixed Operational Cost') then
						PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (toc='Variable Operational Cost') then
						Ptech_useNet(tb,p)*vom_cost(tb,p)*(tech_category(tb)<>"Primary")*(1-(tb in tech_imports))*(nodePer_techBal(tb)=n)
					elseif (toc='National Primary Energy Cost') then
						nationalPrimary_energyCost(n,tb,p)	
					elseif (toc='Import Cost') then
						importCosts_tech(n,tb,p)
					elseif (toc='Export Revenues') then !'National Primary Energy Cost','Import Cost','Export Revenues'
						-exportCosts_tech(n,tb,p)
					elseif (toc='Total Cost') then
						capitalCosts_techBal(n,tb,p)*(nodePer_techBal(tb)=n)
						+PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
						+Ptech_useNet(tb,p)*vom_cost(tb,p)*(tech_category(tb)<>"Primary")*(1-(tb in tech_imports))*(nodePer_techBal(tb)=n)
						+nationalPrimary_energyCost(n,tb,p)
						+importCosts_tech(n,tb,p) 
						-exportCosts_tech(n,tb,p)
					endif
				}
			}
			Parameter SystemCosts_techInfra {
				IndexDomain: (n,toc,ti,p);
				Definition: {
					if (toc='Capital Cost') then
						capitalCosts_techInfra(n,ti,p)*(nodePer_techInfra(ti)=n)
					elseif (toc='Fixed Operational Cost') then
						PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					elseif (toc='Total Cost') then
						capitalCosts_techInfra(n,ti,p)*(nodePer_techInfra(ti)=n)
						+PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					endif
				}
			}
			Parameter SystemCosts {
				IndexDomain: (n,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						sum[tb, SystemCosts_techBal(n,toc,tb,p)] 
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)]
					endif
				}
			}
			Parameter SystemCosts_sec {
				IndexDomain: (n,z,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						if (toc<>'Fuel Costs' and toc<>'Emission Costs' and toc<>'Total Cost') then
							sum[tb, SystemCosts_techBal(n,toc,tb,p)*(tech_sector(tb)=z)]
						elseif (toc='Fuel Costs') then
							sum[tb,fuelCosts_tech(n,tb,p)*(tech_subsector(tb)<>"XC Trade")*(tech_sector(tb)=z)]
						elseif (toc='Emission Costs') then
							sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)]
						elseif (toc='Total Cost') then
							sum[tb, SystemCosts_techBal(n,'Capital Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Fixed Operational Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Variable Operational Cost',tb,p)*(tech_sector(tb)=z)]
							+sum[tb, SystemCosts_techBal(n,'Trading Costs',tb,p)*(tech_sector(tb)=z)]
							+sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)]
							+sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)]
						endif
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)*(tech_sector(ti)=z)]
					endif
				}
			}
			Parameter SystemCosts_act {
				IndexDomain: (n,z,as,tots,toc,p);
				Definition: {
					if (tots='Balancing') then
						if (toc<>'Fuel Costs' and toc<>'Emission Costs' and toc<>'Total Cost') then
							sum[tb, SystemCosts_techBal(n,toc,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Fuel Costs') then
							sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Emission Costs') then
							sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						elseif (toc='Total Cost') then
							sum[tb, SystemCosts_techBal(n,'Capital Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Fixed Operational Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Variable Operational Cost',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb, SystemCosts_techBal(n,'Trading Costs',tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb,(fuelCosts_tech(n,tb,p)-importCosts_tech(n,tb,p))*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
							+sum[tb,emissionCosts_tech(n,tb,p)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)]
						endif
					elseif (tots='Infrastructure') then
						sum[ti, SystemCosts_techInfra(n,toc,ti,p)*(tech_sector(ti)=z)*(infra_activity(ti)=as)]
					endif
				}
			}
			Parameter decPayments_techBal {
				IndexDomain: (n,top,tb,p);
				Definition: {
					if (top='Investment') then
						Pcap_investments(tb,p)*inv_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (top='Decommisioning') then
						0
						!Peco_decommisioning(tb,p)*inv_cost(tb,p)*decom_frac(tb)*(nodePer_techBal(tb)=n)		!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
					elseif (top='Retrofitting') then
						sum[it, Pretrofitting(it,tb,p)*(retro_cost(it,tb))]*(nodePer_techBal(tb)=n)	!Retrofitting costs (based on Excel database input) 
					elseif (top='Operational') then
						PtechStock(tb,p)*fom_cost(tb,p)*(nodePer_techBal(tb)=n)
					elseif (top='Variable') then
						Ptech_use(tb,p)*vom_cost(tb,p)*(nodePer_techBal(tb)=n) !Variable costs (including fuel costs)
						+sum[h, PdeltaU_CHP(h,tb,p)+PdeltaS_shed(h,tb,p)]*vom_cost(tb,p)*(nodePer_techBal(tb)=n) !Deviations in tech use due to flexibility
					endif
				}
			}
			Parameter decPayments_techInfra {
				IndexDomain: (n,top,ti,p);
				Definition: {
					if (top='Investment') then
						Pcap_investments(ti,p)*inv_cost(ti,p)*(nodePer_techInfra(ti)=n)
					elseif (top='Decommisioning') then
						0
						!Peco_decommisioning(tb,p)*inv_cost(tb,p)*decom_frac(tb)*(nodePer_techBal(tb)=n)		!Salvage value (temporarily removed, should be applied for post-2050 lifetimes only)
					elseif (top='Retrofitting') then
						sum[it, Pretrofitting(it,ti,p)*(retro_cost(it,ti))]*(nodePer_techInfra(ti)=n)	!Retrofitting costs (based on Excel database input)
					elseif (top='Operational') then
						PtechStock(ti,p)*fom_cost(ti,p)*(nodePer_techInfra(ti)=n)
					endif
				}
			}
			Parameter decPayments {
				IndexDomain: (n,tots,top,p);
				Definition: {
					if (tots='Balancing') then
						sum[tb, decPayments_techBal(n,top,tb,p)] 
					elseif (tots='Infrastructure') then
						sum[ti, decPayments_techInfra(n,top,ti,p)]
					endif
				}
			}
			Parameter SystemCosts_n {
				IndexDomain: (nn,toc,p);
				Definition: sum[(tots,n), SystemCosts(n,tots,toc,p)*(namePer_node(n)=nn)*IEM_node(n)];
			}
			Parameter SystemCosts_sec_n {
				IndexDomain: (nn,z,tots,toc,p);
				Definition: sum[n, SystemCosts_sec(n,z,tots,toc,p)*(namePer_node(n)=nn)*IEM_node(n)]*(toc<>'Total Cost');
			}
			Parameter LCOP_secE {
				IndexDomain: (nn,z,tots,toc,p);
				Definition: {
					((z='Power NL')+(z='Refineries')+(z='Heat Network')+(z='Final Gas')+(z='Hydrogen')+(z='Ammonia'))*(toc<>'Trading Costs')*
					SystemCosts_sec_n(nn,z,tots,toc,p)/(sum[as, output_actMain(nn,z,as,p)]+1e-20)
				}
			}
			Parameter SystemCosts_act_n {
				IndexDomain: (nn,z,as,tots,toc,p);
				Definition: sum[n, SystemCosts_act(n,z,as,tots,toc,p)*(namePer_node(n)=nn)*IEM_node(n)]*(toc<>'Total Cost');
			}
			Parameter LCOP_act {
				IndexDomain: (nn,z,as,tots,toc,p);
				Definition: (toc<>'Trading Costs')*SystemCosts_act_n(nn,z,as,tots,toc,p)/(output_actMain(nn,z,as,p)+1e-20);
			}
			Parameter SystemCosts_sec_tot {
				IndexDomain: (nn,z,p);
				Definition: sum[(tots,toc), SystemCosts_sec_n(nn,z,tots,toc,p)*IEM_sector(z)];
			}
			Parameter SectoralCosts_cascade {
				IndexDomain: (nn,z,toc,pnz);
				Definition: {
					if (pnz=element(periods_nonzeros,1)) then
						sum[tots, SystemCosts_sec_n(nn,z,tots,toc,pnz)]
					else
						sum[tots, SystemCosts_sec_n(nn,z,tots,toc,pnz)]-sum[tots, SystemCosts_sec_n(nn,z,tots,toc,element(periods_nonzeros,1))]
					endif
				}
			}
		}
		DeclarationSection Configuration {
			Set typesOf_planningDecisions {
				Index: topd, itopd, jtopd;
				Definition: {
					{'Investment','Retrofitting additions','Retrofitting substractions','Economic decommissioning'}
				}
			}
			Parameter SectoralConfiguration_stock {
				IndexDomain: (nn,z,as,tots,t,p);
				Definition: {
					if (tots='Balancing') then
						PtechStock(t,p)
						*(tech_sector(t)=z)
						*(activityPer_tech(t)=as)
						*IEM_node(nodePer_techBal(t))
						*(t in tech_balancers)
						*(namePer_node(nodePer_techBal(t))=nn)
					elseif(tots='Infrastructure') then
						PtechStock(t,p)
						*(tech_sector(t)=z)
						*(infra_activity(t)=as)
						*IEM_node(nodePer_techInfra(t))
						*(t in tech_infra)
						*(namePer_node(nodePer_techInfra(t))=nn)
					endif
				}
			}
			Parameter SectoralConfiguration_use {
				IndexDomain: (nn,z,as,tots,t,p);
				Definition: {
					if (tots='Balancing') then
						Ptech_useNet(t,p)
						*(tech_sector(t)=z)
						*(activityPer_tech(t)=as)
						*IEM_node(nodePer_techBal(t))
						*(t in tech_balancers)
						*(namePer_node(nodePer_techBal(t))=nn)
					elseif(tots='Infrastructure') then
						Ptech_useNet(t,p)
						*(tech_sector(t)=z)
						*(infra_activity(t)=as)
						*IEM_node(nodePer_techInfra(t))
						*(t in tech_infra)
						*(namePer_node(nodePer_techInfra(t))=nn)
					endif
				}
			}
			Parameter EnergyShare_tech {
				IndexDomain: (n,ae,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*(activity_balances(tb,ae,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)
					/sum[(itb), (nodePer_techBal(tb)=n)*(activity_balances(itb,ae,p)>0)*Ptech_useNet(itb,p)*activity_balances(itb,ae,p)+1e-9]
				}
			}
			Parameter PlanningDecisions_tech {
				IndexDomain: (nn,t,topd,p);
				Definition: {
					if (topd='Investment') then
						((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*Pcap_investments(t,p)
					elseif (topd='Retrofitting additions') then
						((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*sum[it, Pretrofitting(it,t,p)]
					elseif (topd='Retrofitting substractions') then
						-((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*sum[jt, Pretrofitting(t,jt,p)]
					elseif (topd='Economic decommissioning') then
						-((t in tech_balancers)*IEM_node(nodePer_techBal(t))*(namePer_node(nodePer_techBal(t))=nn)
						+(t in tech_infra)*IEM_node(nodePer_techInfra(t))*(namePer_node(nodePer_techInfra(t))=nn))
						*Peco_decommisioning(t,p)
					endif
				}
			}
		}
		DeclarationSection Power_sector {
			Set electricity_activities {
				SubsetOf: activities_hour;
				Index: ahee, iahee, jahee;
				Definition: {
					{ah | labelPer_act(ah)='Electricity'}
				}
			}
			Set typeOf_PowerInfo {
				Index: topi, itopi, jtopi;
				Definition: {
					{'Stock','Use'}
				}
			}
			ElementParameter sourcePer_line {
				IndexDomain: th;
				Range: activities_solve;
				Definition: {
					actSolvePer_actOrig(first({ao | activity_balancesRef(th,ao)*(tech_subsector(th)="XC Trade")<0})) !(Hardcode)
				}
			}
			Parameter Power_dispatch {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter Power_stock {
				IndexDomain: (nn,tb,p);
				Definition: {
					PtechStock(tb,p)
					*(tech_subsector(tb)="Generation") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*IEM_node(nodePer_techBal(tb))
				}
			}
			Parameter Power_gen {
				IndexDomain: (nn,tb,p);
				Definition: {
					Ptech_use(tb,p)
					*(tech_subsector(tb)="Generation") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*IEM_node(nodePer_techBal(tb))
				}
			}
			Parameter XC_stock {
				IndexDomain: (inn,nn,tb,p);
				Definition: {
					PtechStock(tb,p)
					*(tech_subsector(tb)="XC Trade") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*(namePer_node(nodePer_act(sourcePer_line(tb)))=inn)
				}
			}
			Parameter XC_use {
				IndexDomain: (inn,nn,tb,p);
				Definition: {
					Ptech_use(tb,p)
					*(tech_subsector(tb)="XC Trade") !(Hardcode)
					*(namePer_node(nodePer_techBal(tb))=nn)
					*(namePer_node(nodePer_act(sourcePer_line(tb)))=inn)
				}
			}
			Parameter PowerInfo_act {
				IndexDomain: (ahee,topi,tb,p);
				Definition: {
					!(HARDCODED)
					if (topi='Stock') then
						PtechStock(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Generation")
						+PtechStock(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Storage")
					elseif (topi='Use') then
						Ptech_useNet(tb,p)*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Generation")
						+sum[h, PdeltaQ_DW(h,tb,p)]*(activityPer_tech(tb)=ahee)*(tech_subsector(tb)="Storage")
					endif
				}
			}
			Parameter XCinfo_act {
				IndexDomain: (iahee,ahee,topi,tb,p);
				Definition: {
					!(HARDCODED)
					if (topi='Stock') then
						PtechStock(tb,p)
						*(tech_subsector(tb)="XC Trade") !(Hardcode)
						*(activityPer_tech(tb)=ahee)
						*(sourcePer_line(tb)=iahee)
					elseif (topi='Use') then
						Ptech_useNet(tb,p)
						*(tech_subsector(tb)="XC Trade") !(Hardcode)
						*(activityPer_tech(tb)=ahee)
						*(sourcePer_line(tb)=iahee)
					endif
				}
			}
			Parameter CHP_output {
				IndexDomain: (tk,ae,p);
				Definition: {
					!(activity_balances(tk,ae,p)>0)*
					Ptech_useNet(tk,p)*activity_balances(tk,ae,p)
				}
			}
			Parameter CHP_input {
				IndexDomain: (tk,ae,p);
				Definition: {
					(activity_balances(tk,ae,p)>0)*
					Ptech_useNet(tk,p)*activity_balances(tk,ae,p)
				}
			}
		}
		DeclarationSection Emissions {
			Parameter emissions_all {
				IndexDomain: (nn,t_c,p);
				Definition: (namePer_node(nodePer_techBal(t_c))=nn)*Ptech_useNet(t_c,p)*IEM_node(nodePer_techBal(t_c));
			}
			Parameter emissions_sec {
				IndexDomain: (nn,z,ac,p);
				Definition: sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*Ptech_useNet(tb,p)*activity_balances(tb,ac,p)*IEM_node(nodePer_techBal(tb))];
			}
			Parameter emissions_act {
				IndexDomain: (nn,z,as,ac,p);
				Definition: sum[tb, (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,ac,p)*IEM_node(nodePer_techBal(tb))];
			}
			Parameter emissions_tech {
				IndexDomain: (nn,z,as,tb,ac,p);
				Definition: (namePer_node(nodePer_techBal(tb))=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*activity_balances(tb,ac,p)*IEM_node(nodePer_techBal(tb));
			}
			Parameter emissions_cum {
				IndexDomain: n;
				Definition: {
					!The sum of the use of all the emissions released to air in each node
					sum[(tb,ps), Ptech_use(tb,ps)*(nodePer_act(activityPer_tech(tb))=n)*(activityPer_tech(tb) in activities_target)*period_weightUSE(ps)*transition_interval]
				}
			}
		}
		DeclarationSection Balances {
			Set typesOf_balances {
				Index: tob, itob, jtob;
				Definition: {
					{'supply','demand'}
				}
			}
			Set typesOf_decomposition {
				Index: tod, itod, jtod;
				Definition: {
					{'Net Primary','Net energy transformations','Total final incl.','Int. Transport',
					'Total final excl.','Feedstock','Final energy use','Final Losses','Electricity final','Electricity total'}
				}
			}
			Set typesOf_final {
				Index: tof, itof, jtof;
				Definition: {
					{'Energy Use','Feedstock'}
				}
			}
			Set typesOf_primaryEnergy {
				Index: tope, itope, jtope;
				Definition: {
					{'Total','Exports','Net'}
				}
			}
			Set typesOf_sankeyElements {
				SubsetOf: set_of_everything;
				Index: tos, itos, jtos;
			}
			Set typesOf_use {
				Index: tou, itou, jtou;
				Definition: {
					{'Primary','Conversion','Final','Exports','Losses'}
				}
			}
			Set international_transport {
				SubsetOf: activities_solve;
				Definition: {
					if (ord('CO2 Air Int. Transport',activities_solve)<>0) then
						{as | sum[(tb,p) | (activityPer_tech(tb)=as), activity_balances(tb,'CO2 Air Int. Transport',p)]<0}
					endif
				}
			}
			Parameter final_activities {
				IndexDomain: (n,as,p);
				Definition: {
					(nodePer_act(as)=n)*(
					sum[t, (nodePer_techBal(t)=n)*Ptech_use(t,p)*activity_balances(t,as,p)]+  !Reference activity balance
					sum[tf, sum[h, (nodePer_techBal(tf)=n)*(PdeltaQ_UP(h,tf,p)+PdeltaQ_DW(h,tf,p))]*dQ_hourly(tf,as)]+ !Impact of flexibility in hourly activities
					sum[tk, sum[h, (nodePer_techBal(tk)=n)*PdeltaU_CHP(h,tk,p)]*activity_balances(tk,as,p)]+ !Impact of use deviation of CHPs
					sum[tk, sum[h, (nodePer_techBal(tk)=n)*PdeltaP_CHP(h,tk,p)]*dP_electricity(tk,as)]+ !Impact in power of power output ratio deviation of CHPs
					sum[tk, sum[h, -(nodePer_techBal(tk)=n)*CHP_eta(tk)*PdeltaP_CHP(h,tk,p)/CHP_eps(tk,p)]*dP_heat(tk,as)]+ !Impact in heat of power output ratio deviation of CHPs
					sum[ts, sum[h, (nodePer_techBal(ts)=n)*PdeltaS_shed(h,ts,p)]*activity_balances(ts,as,p)] !Impact of shedding load
					)
				}
			}
			Parameter feedstockUse_techOrig {
				IndexDomain: (t,ao);
			}
			Parameter feedstockUse_tech {
				IndexDomain: (t,as);
				Definition: feedstockUse_techOrig(t,as)+sum[iao | groupOf_activities(as,iao)=1, feedstockUse_techOrig(t,iao)];
			}
			Parameter feedstockUse_sec {
				IndexDomain: (n,z,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector(tb)=z)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)];
			}
			Parameter feedstockUse_act {
				IndexDomain: (n,z,as,el,p);
				Definition: sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*Ptech_useNet(tb,p)*feedstockUse_tech(tb,ae)*(labelPer_act(ae)=el)];
			}
			Parameter supplyAct_tech {
				IndexDomain: (n,as,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					((activity_balances(tb,as,p)*(1-2*(as in activities_emission)))>0)
					*(Ptech_useNet(tb,p)*activity_balances(tb,as,p)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,p)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter demandAct_tech {
				IndexDomain: (n,as,tb,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					((activity_balances(tb,as,p)*(1-2*(as in activities_emission)))<0)
					*(Ptech_useNet(tb,p)*activity_balances(tb,as,p)+  !Reference activity balance
					sum[h, PdeltaQ_DW(h,tb,p)]*dQ_hourly(tb,as)+ !Impact of flexibility in hourly activities
					!sum[tg, sum[d, (deltaB_DW(d,tg,p)-deltaB_UP(d,tg,p))]*activity_balances(tg,as,p)]+ !Impact of gas buffers energy consumption
					sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,as)+ !Impact in power of power output ratio deviation of CHPs
					sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,as) !Impact in heat of power output ratio deviation of CHPs
					)
				}
			}
			Parameter supdemAct_tech {
				IndexDomain: (nn,as,tob,tb,p);
				Definition: {
					if(tob='supply') then
						sum[n, (namePer_node(n)=nn)*supplyAct_tech(n,as,tb,p)*IEM_node(n)]
					elseif(tob='demand') then
						sum[n, (namePer_node(n)=nn)*demandAct_tech(n,as,tb,p)*IEM_node(n)]
					endif
				}
			}
			Parameter energyUse_tech {
				IndexDomain: (n,tb,ae,p);
				Definition: {
					(nodePer_techBal(tb)=n)*
					(Ptech_useNet(tb,p)*activity_balances(tb,ae,p)  !Reference activity balance
					+sum[h, (PdeltaQ_UP(h,tb,p)+PdeltaQ_DW(h,tb,p))]*dQ_hourly(tb,ae) !Impact of flexibility in hourly activities
					+sum[h, PdeltaP_CHP(h,tb,p)]*dP_electricity(tb,ae) !Impact in power of power output ratio deviation of CHp
					+sum[h, -CHP_eta(tb)*PdeltaP_CHP(h,tb,p)/CHP_eps(tb,p)]*dP_heat(tb,ae) !Impact in heat of power output ratio deviation of CHp
					)
				}
			}
			Parameter energyUse_act {
				IndexDomain: (nn,z,as,ae,p);
				Definition: sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)];
			}
			Parameter output_actAll {
				IndexDomain: (nn,z,as,ias,p);
				Definition: {
					sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(nodePer_techBal(tb)=n)*
							(activity_balances(tb,ias,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ias,p)]
				}
			}
			Parameter output_actMain {
				IndexDomain: (nn,z,as,p);
				Definition: {
					sum[(n,tb), (namePer_node(n)=nn)*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(nodePer_techBal(tb)=n)*
							Ptech_useNet(tb,p)*activity_balances(tb,as,p)]
				}
			}
			Parameter finalEnergy_sec {
				IndexDomain: (n,z,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use
					
					 !below added by Kira to correct for "conversion" material processes and CCUS
					
					 !Final enery use for industrial material conversion processes
					 + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityType_act(activityPer_tech(tb))='Material conversion')*(tech_sector(tb)=z))<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)]
					
					!CCUS
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(tech_sector(tb)=z))<>0,
					 (energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el))]
				}
			}
			Parameter finalEnergy_actEL {
				IndexDomain: (n,z,as,el,p);
				Definition: {
					sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
					((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use
					  !added by Kira to correct for "conversion" material processes and CCUS
					  + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Conversion')*(tech_sector(tb)='Industry')*(activityPer_tech(tb)=as))*(activityType_act(activityPer_tech(tb))='Material conversion')<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use for industrial material conversion processes
					   + sum[(tb,ae) | ((nodePer_techBal(tb)=n)*(tech_category(tb)='Emission')*(tech_sector(tb)='Industry')*(activityPer_tech(tb)=as))<>0,
					 energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=el)] !Final enery use for CCUS
				}
			}
			Parameter finalEnergy_matrix {
				IndexDomain: (nn,z,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]*(z<>'Waste')*(el<>'Material') !(HARDCODED)
					endif
					!edited by Kira to correct for material flows
				}
			}
			Parameter finalEnergy_matrixAct {
				IndexDomain: (nn,z,as,tof,el,p);
				Definition: {
					if (tof='Energy Use') then
						sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z<>'Waste')*(el<>'Material')*(activityType_act(as)='Driver') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z<>'Waste')*(el<>'Material')*(activityType_act(as)='Driver') !(HARDCODED)
						+ sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Material conversion') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Material conversion') !(HARDCODED)
						+ sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Emission') !(HARDCODED)
						-sum[n, (namePer_node(n)=nn)*finalEnergy_actEL(n,z,as,el,p)]*(z='Industry')*(el<>'Material')*(activityType_act(as)='Emission') !(HARDCODED)
					elseif(tof='Feedstock') then
						-sum[n, (namePer_node(n)=nn)*feedstockUse_act(n,z,as,el,p)]*(el<>'Material')*(z<>'Waste') !(HARDCODED)
					endif
					!edited by Kira to correct for material flows
					!added by Kira to correct for material conversion activities (need to finalize this with material conversion as activity type
				}
			}
			Parameter finalEnergy_act {
				IndexDomain: (nn,z,as,p);
				Definition: {
					sum[(tb,ae,n) | ((tech_category(tb)='Final')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(activityType_act(activityPer_tech(tb))='Driver'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					+sum[(tb,ae,n) | ((tech_category(tb)='Emission')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(activityType_act(activityPer_tech(tb))='Emission'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					 +sum[(tb,ae,n) | ((tech_category(tb)='Conversion')*(tech_sector(tb)=z)*(activityPer_tech(tb)=as)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))='Material'))<0,
					 energyUse_tech(n,tb,ae,p)*(nodePer_techBal(tb)=n)*(namePer_node(n)=nn)] !(HARDCODED)
					 !final element added by Kira to account for material conversion processes that belong to the "final" end use sectors
				}
			}
			Parameter primaryEnergy {
				IndexDomain: (n,el,p);
				Definition: {
					sum[(tb,ae), (nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*(labelPer_act(ae)=el)*(labelPer_act(ae)<>'Material')*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)]
					!edited by Kira to account for material flows
				}
			}
			Parameter exportsEnergy {
				IndexDomain: (n,el,p);
				Definition: {
					!-sum[(tb,ae), (nodePer_techBal(tb)<>n)*(nodePer_act(ae)=n)*(activity_balances(tb,ae,p)<0)*(labelPer_act(ae)=el)
					!*Ptech_useNet(tb,p)*activity_balances(tb,ae,p)] !Technologies that are connected to other networks
					
					+sum[ae, final_activities(n,ae,p)*(labelPer_act(ae)=el)*(labelPer_act(ae)<>'Material')]!sum[ae, (nodePer_act(ae)=n)*(labelPer_act(ae)=el)] !Activities that are over-produced
					!edited by Kira to account for exported materials
				}
			}
			Parameter primaryBalance {
				IndexDomain: (nn,tope,el,p);
				Definition: {
					!Hardcoded
					if (tope='Total') then
						sum[n, (namePer_node(n)=nn)*primaryEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*primaryEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					elseif(tope='Exports') then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					elseif(tope='Net') then
						sum[n, (namePer_node(n)=nn)*primaryEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,el,p)*IEM_node(n)]*(el<>'Oil')
						+sum[n, (namePer_node(n)=nn)*primaryEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
						-sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil',p)*IEM_node(n)]*(el='Oil Products')
					endif
				}
			}
			Parameter EnergyExclussiveness {
				IndexDomain: (n,tb,ae,p);
				Definition: {
					(energyUse_tech(n,tb,ae,p)>0)*energyUse_tech(n,tb,ae,p)/
					(sum[iae,(energyUse_tech(n,tb,iae,p)>0)*energyUse_tech(n,tb,iae,p)]+1e-12)
				}
			}
			Parameter sankey_flows {
				IndexDomain: (nn,tou,itos,jtos,p);
				Definition: {
					!(HARDCODED)
					!edited by Kira to account for material flows and allocation of material conversion to final industry sector - STILL NEEDS WORK
					if (tou = 'Final') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)=jtos)*(tech_category(tb)="Final")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)=jtos)*(tech_category(tb)="Emission")*(labelPer_act(ae)<>'Material')]
						!-sum[(n,tb,ae), (energyUse_tech(n,tb,ae,p)<0)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=itos)*(tech_sector(tb)='Industry')*(tech_category(tb)="Conversion")*(labelPer_act(ae)='Material')]
						!-sum[(n,tb,amc), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(energyUse_tech(n,tb,amc,p)<0)*energyUse_tech(n,tb,amc,p)*(labelPer_act(amc)=itos)*(tech_sector(tb)='Industry')*(labelPer_act(amc)='Material')]
					
					elseif (tou = 'Conversion') then
						-sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_sector(tb)='Waste Disposal')
						*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						*(energyUse_tech(n,tb,ae,p)<0)*(tech_sector(tb)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)]
						-sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Conversion")
						*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						*(energyUse_tech(n,tb,ae,p)<0)*(labelPer_act(ae)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)]
						!+sum[(n,tb,ae,iae)| (labelPer_act(ae)<>'Material'), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Conversion")
						!*energyUse_tech(n,tb,ae,p)*EnergyExclussiveness(n,tb,iae,p)
						!*(energyUse_tech(n,tb,ae,p)<0)*(labelPer_act(ae)=itos)*(energyUse_tech(n,tb,iae,p)>0)*(labelPer_act(iae)=jtos)*(itos<>jtos)*(labelPer_act(iae)<>'Material')*(tech_sector(tb)='Industry')]
					
					elseif (tou = 'Exports') then
						sum[n, IEM_node(n)*(namePer_node(n)=nn)*exportsEnergy(n,itos,p)*(jtos='Exports')]
					
					elseif (tou = 'Losses') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=itos)*(labelPer_act(activityPer_tech(tb))<>'Material')*(jtos='Losses')*(tech_category(tb)="Conversion")]
					
					elseif (tou = 'Primary') then
						(itos='Primary')*(
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Final")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Emission")*(labelPer_act(ae)<>'Material')]
						+sum[n, IEM_node(n)*(namePer_node(n)=nn)*exportsEnergy(n,jtos,p)]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(ae)=jtos)*(tech_category(tb)="Primary")*(labelPer_act(ae)<>'Material')]
						+sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Conversion")*(labelPer_act(ae)<>'Material')]
						+sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*energyUse_tech(n,tb,ae,p)*(labelPer_act(activityPer_tech(tb))=jtos)*(tech_category(tb)="Primary")*(labelPer_act(ae)<>'Material')]
						)
					
					endif
				}
			}
			Parameter final_decomposition {
				IndexDomain: (nn,tod,p);
				Definition: {
					!(HARDCODE)
					if (tod='Net Primary') then 
						sum[el, primaryBalance(nn,'Net',el,p)]
					elseif (tod='Net energy transformations') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(tech_category(tb)='Conversion')*energyUse_tech(n,tb,ae,p)] !National drivers
					elseif (tod='Total Final incl.') then
						-sum[(z,as), (z<>'Waste')*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Int. Transport') then
						-sum[(z,as), (as in international_transport)*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Total Final excl.') then
						-sum[(z,as), (z<>'Waste')*((as in international_transport)=0)*finalEnergy_act(nn,z,as,p)]
					elseif (tod='Feedstock') then
						-sum[(n,z,el), IEM_node(n)*(namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]
					elseif (tod='Final energy use') then
						-sum[(z,as), (z<>'Waste')*((as in international_transport)=0)*finalEnergy_act(nn,z,as,p)]
						+sum[(n,z,el), IEM_node(n)*(namePer_node(n)=nn)*feedstockUse_sec(n,z,el,p)]
					elseif (tod='Final losses') then
						-sum[(n,tb,ae), IEM_node(n)*(namePer_node(n)=nn)*(tech_subsector(tb)='Heat')*(tech_category(tb)='Conversion')*energyUse_tech(n,tb,ae,p)]
					elseif (tod='Electricity final') then
						sum[(tof,z), finalEnergy_matrix(nn,z,tof,'Electricity',p)]
					elseif (tod='Electricity total') then
						electricity_parameters(nn,'net',p)
					endif
				}
			}
			Parameter primary_renewable {
				IndexDomain: (nn,el,p);
				Definition: (el in renewables)*primaryBalance(nn,'Net',el,p);
			}
		}
		DeclarationSection Profiles {
			Set typesOf_3Dactivity {
				SubsetOf: activities_solve;
				Index: t3a, it3a, jt3a;
				Definition: activities_hour + {as | (labelPer_act(as)='Solar' or labelPer_act(as)='Wind')};
			}
			Set typesOf_profiles {
				Index: topp, itopp, jtopp;
				Definition: {
					{'reference','final'}
				}
			}
			Set typesOf_RLparameters {
				Index: torl, itorl, jtorl;
				Definition: {
					{'Load (no flex)','Wind','Solar','Run of River','Baseload Generation','Residual Load','Imports','Exports','Shedding','CHPs UP','CHPs DW','Smart Charging UP',
					'Smart Charging DW','V-to-G UP','V-to-G DW','Load Shifting UP','Load Shifting DW','Storage UP','Storage DW','Curtailment','Remaining'}
				}
			}
			Set typesOf_RLdirections {
				Index: torld, itorld, jtorld;
				Definition: {
					{'Deficit','Surplus'}
				}
			}
			Set typesOf_RLflexibility {
				Index: torlf, itorlf, jtorlf;
				Definition: {
					{'Imports','Exports','Curtailment','Storage','Flex Generation','Demand Response','Other'}
				}
			}
			Parameter loadProfiles_H {
				IndexDomain: (nn,h,ah,p);
				InitialData: 0;
			}
			Parameter refProfiles_H {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter finProfiles_H {
				IndexDomain: (nn,h,tb,p);
				InitialData: 0;
			}
			Parameter loadProfiles_D {
				IndexDomain: (nn,d,ad,p);
				InitialData: 0;
			}
			Parameter refProfiles_D {
				IndexDomain: (nn,d,tg,p);
				InitialData: 0;
			}
			Parameter finProfiles_D {
				IndexDomain: (nn,d,tg,p);
				InitialData: 0;
			}
			Parameter flexProfiles_H {
				IndexDomain: (nn,topp,h,tb,p);
			}
			Parameter profiles3D {
				IndexDomain: (nn,w,h_d,t3a,p);
				InitialData: 0;
			}
			Parameter residual_load {
				IndexDomain: (nn,h,torl,p);
				InitialData: 0;
			}
			Parameter diferential_resLoad {
				IndexDomain: (nn,h,p);
				InitialData: 0;
			}
			Parameter decomposition_resLoad {
				IndexDomain: (nn,h,torlf,p);
				InitialData: 0;
			}
			Parameter decomposition_resLoadY {
				IndexDomain: (nn,torlf,p);
				Definition: sum[h, decomposition_resLoad(nn,h,torlf,p)];
			}
		}
		DeclarationSection Other_results {
			Set typesOf_electricityParameters {
				Index: toep, itoep, jtoep;
				Definition: {
					{'load','import','export','net','cost','variability','unserved'}
				}
			}
			Set typesOf_flexibility {
				Index: tox, itox, jtox;
				Definition: {
					{'flexible_CHPs','shedding','demand_response','storage','passive_storage','smart_charging','vehicle-to-grid','imports','exports','curtailment'}
				}
			}
			Set typesOf_keyIndicators {
				Index: tok, itok, jtok;
				Definition: {
					{'CO2 Target','CO2 Price','Hydrogen Use','Ammonia Use','RES share in primary','RES share in final electricity',
					'Final electrification','Final Energy Cost','Primary Energy Cost','CO2 Storage Potential','Net Emissions',
					'UP flex demand','DW flex demand','Oil Products Exports','Synfuels Exports','Biofuels Exports'}
				}
			}
			Set typesOf_intTransResults {
				Index: toitr, itoitr, jtoitr;
				Definition: {
					{'Emissions','Shadow Price'}
				}
			}
			Parameter RESelec_share {
				IndexDomain: (tb,p);
				Definition: {
					sum[(ae,iae), (labelPer_act(ae)='Electricity')*(activity_balances(tb,ae,p)>0)
					*(activity_balances(tb,iae,p)<0)*(labelPer_act(iae) in renewables)*activity_balances(tb,iae,p)]/
					sum[(ae,iae), (labelPer_act(ae)='Electricity')*(activity_balances(tb,ae,p)>0)*(activity_balances(tb,iae,p)<0)*activity_balances(tb,iae,p)+1e-9]
				}
			}
			Parameter key_indicators {
				IndexDomain: (nn,tok,p);
				Definition: {
					!(HARDCODED)
					if (tok='CO2 Target') then
						(sum[n, (namePer_node(n)=nn)*IEM_node(n)]-sum[n, (namePer_node(n)=nn)*IEM_node(n)*(emissionTarget(n,p)-2*roomFor_negative)/(emissionTarget(n,'2020')-2*roomFor_negative+0.00001)])*100
					elseif (tok='CO2 Price') then
						-sum[n, (namePer_node(n)=nn)*IEM_node(n)*CO2_price_single(n,p)]
					elseif (tok='Hydrogen Use') then
						sum[jtos, sankey_flows(nn,'Final','Hydrogen',jtos,p)+sankey_flows(nn,'Conversion','Hydrogen',jtos,p)]
					elseif (tok='Ammonia Use') then
						sum[jtos, sankey_flows(nn,'Final','Ammonia',jtos,p)+sankey_flows(nn,'Conversion','Ammonia',jtos,p)]
					elseif (tok='RES share in primary') then
						100*
						sum[el, (el in renewables)*primaryBalance(nn,'Net',el,p)]/sum[el, primaryBalance(nn,'Net',el,p)+1e-6 | primaryBalance(nn,'Net',el,p)>=0]
					elseif (tok='RES share in final electricity') then
						100*
						sum[(n,tb,as), (namePer_node(n)=nn)*IEM_node(n)*(nodePer_techBal(tb)=n)*(labelPer_act(as)='Electricity')
						*(activity_balances(tb,as,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,as,p)*(tech_subsector(tb)<>'XC Trade')*RESelec_share(tb,p)]
						/sum[(n,as,tb), (namePer_node(n)=nn)*IEM_node(n)*(nodePer_techBal(tb)=n)*(labelPer_act(as)='Electricity')
						*(activity_balances(tb,as,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,as,p)*(tech_subsector(tb)<>'XC Trade')+1e-9]
					elseif (tok='Final electrification') then
						100*
						final_decomposition(nn,'Electricity final',p)/(final_decomposition(nn,'Final energy use',p)+1e-9)
					elseif (tok='Final Energy Cost') then
						sum[(n,tb,ae) | ((namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(tech_sector(tb)<>'Waste')*!Not to account waste sector
						((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
						energyUse_tech(n,tb,ae,p)*EnergyCosts_mean(ae,p)]/ !Final enery use times its mean cost
						(sum[(n,tb,ae) | ((namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)='Final')*(activityType_act(activityPer_tech(tb))='Driver'))<>0,
						(tech_sector(tb)<>'Waste')*!Not to account waste sector
						((activityPer_tech(tb) in international_transport)=0)* !Not in international transport
						energyUse_tech(n,tb,ae,p)]+1e-20)
					elseif (tok='Primary Energy Cost') then
						sum[(n,tb,ae), (namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*
						Ptech_useNet(tb,p)*activity_balances(tb,ae,p)*EnergyCosts_mean(ae,p)]/
						(sum[(n,tb,ae), (namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_category(tb)="Primary")*(activityPer_tech(tb)=ae)*
						Ptech_useNet(tb,p)*activity_balances(tb,ae,p)]+1e-20)
					elseif (tok='CO2 Storage Potential') then
						sum[(n,tb), (namePer_node(n)=nn)*IEM_node(n)*(tech_name(tb)="CO2 Storage")*Ptech_useNet(tb,p)]
					elseif (tok='Net Emissions') then
						sum[(n,t_c), (namePer_node(n)=nn)*IEM_node(n)*(tech_sector(t_c)='Emission')*emissions_all(nn,t_c,p)]
					elseif(tok='UP flex demand')*(HourlyReportValue = 'yes') then
						sum[h, (residual_load(nn,h,'Residual Load',p)>0)*residual_load(nn,h,'Residual Load',p)]
					elseif(tok='DW flex demand')*(HourlyReportValue = 'yes') then
						sum[h, (residual_load(nn,h,'Residual Load',p)<0)*residual_load(nn,h,'Residual Load',p)]
					elseif(tok='Oil Products Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Oil Products',p)]
					elseif(tok='Synfuels Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Synfuels',p)]
					elseif(tok='Biofuels Exports')then
						sum[n, (namePer_node(n)=nn)*exportsEnergy(n,'Bio-fuels',p)]
					endif
				}
			}
			Parameter curtailmentRES {
				IndexDomain: (nn,th,p);
				Definition: {
					if sum[ae, (labelPer_act(ae)='Wind' or labelPer_act(ae)='Solar')*activity_balances(th,ae,p)]<0 then
						+(namePer_node(nodePer_techBal(th))=nn)*(PtechStock(th,p)*cap2act(th)-Ptech_use(th,p))
					elseif (StringOccurrences(profileType_tech(th),"Hydro RoR")>0) then
						+(namePer_node(nodePer_techBal(th))=nn)*(PtechStock(th,p)*cap2act(th)-Ptech_use(th,p))
					endif
				}
			}
			Parameter electricity_parameters {
				IndexDomain: (nn,toep,p);
				Definition: {
					if (toep='load') then
						sum[(n,tb,ahe) | sum[iahe,activity_balances(tb,iahe,p)]>0, IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)=n)
						*(activity_balances(tb,ahe,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]	
					elseif (toep='import') then
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
						*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='export') then
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
						*(activity_balances(tb,ahe,p)<0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='net') then
						sum[(n,tb,ahe) | sum[iahe,activity_balances(tb,iahe,p)]>0, IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)=n)
						*(activity_balances(tb,ahe,p)>0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
						+sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
						*(activity_balances(tb,ahe,p)<0)*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
						-sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
						*Ptech_useNet(tb,p)*activity_balances(tb,ahe,p)]
					elseif (toep='cost') then
						sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*EnergyCosts(h,ahe,p)]/sum[ahe, (namePer_node(nodePer_act(ahe))=nn)*card(hours)+0.00001]
					elseif (toep='variability') then
						sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*abs(EnergyCostsVariability(h,ahe,p))]/sum[ahe, (namePer_node(nodePer_act(ahe))=nn)*card(hours)+0.00001]
					elseif (toep='unserved') then
						-sum[(n,tb,ahe), -(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)=n)
						*(tech_subsector(tb)="Undispatched")*Ptech_useNet(tb,p)]
					endif
				}
			}
			Parameter flexibility_volumes {
				IndexDomain: (nn,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
						(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
						-sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
						(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					endif
				}
			}
			Parameter flexibility_volumesAct {
				IndexDomain: (nn,z,as,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*(tech_sector(tk)=z)*(activityPer_tech(tk)=as)*
						abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*(tech_sector(ts)=z)*(activityPer_tech(ts)=as)*
						PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*
						PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(tech_sector(tb)=z)*
						(activityPer_tech(tb)=as)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(tech_sector(tb)=z)*
						(activityPer_tech(tb)=as)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
						(tech_sector(th)=z)*(activityPer_tech(th)=as)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
						-sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
						(tech_sector(th)=z)*(activityPer_tech(th)=as)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					endif
					
					!if (tox='flexible_CHPs') then
					!	sum[(h,tk,ah), (namePer_node(nodePer_techBal(tk))=nn)*(tech_sector(tk)=z)*(activityPer_tech(tk)=as)*(tk=itb)*
					!	abs(PdeltaU_CHP(h,tk,p)*activity_balances(tk,ah,p)+PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)*(ah in activitiesHour_electricity))]/2
					!elseif (tox='shedding') then
					!	sum[(h,ts,ah), (namePer_node(nodePer_techBal(ts))=nn)*(tech_sector(ts)=z)*(activityPer_tech(ts)=as)*(ts=itb)*
					!	PdeltaS_shed(h,ts,p)*activity_balances(ts,ah,p)*(ah in activitiesHour_electricity)]
					!elseif (tox='demand_response') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='DR shifting')*(ah in activitiesHour_electricity)]
					!elseif (tox='storage') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='Storage')*(ah in activitiesHour_electricity)]
					!elseif (tox='passive_storage') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='BE shifting')*(ah in activitiesHour_electricity)]
					!elseif (tox='smart_charging') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV smart charge')*(ah in activitiesHour_electricity)]
					!elseif (tox='vehicle-to-grid') then
					!	-sum[(h,tf,ah), (namePer_node(nodePer_techBal(tf))=nn)*(tech_sector(tf)=z)*(activityPer_tech(tf)=as)*(tf=itb)*
					!	PdeltaQ_UP(h,tf,p)*dQ_hourly(tf,ah)*(flexibilityType_tech(tf)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					!elseif (tox='imports') then
					!	sum[(h,tb,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*(tech_sector(tb)=z)*
					!	(activityPer_tech(tb)=as)*(tb=itb)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					!elseif (tox='exports') then
					!	sum[(h,tb,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*(tech_sector(tb)=z)*
					!	(activityPer_tech(tb)=as)*(tb=itb)*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					!elseif (tox='curtailment') then
					!	sum[(h,th,ae), (namePer_node(nodePer_techBal(th))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*(activity_balances(th,ae,p)<0)*
					!	(tech_sector(th)=z)*(activityPer_tech(th)=as)*(th=itb)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					!	+sum[(h,th), (namePer_node(nodePer_techBal(th))=nn)*(StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*
					!	(tech_sector(th)=z)*(activityPer_tech(th)=as)*(th=itb)*(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					!endif
				}
			}
			Parameter flexibility_volumesTech {
				IndexDomain: (nn,tb,tox,p);
				Definition: {
					if (tox='flexible_CHPs') then
						sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						abs(PdeltaU_CHP(h,tb,p)*activity_balances(tb,ah,p)+PdeltaP_CHP(h,tb,p)*dP_electricity(tb,ah)*(ah in activitiesHour_electricity))]/2
					elseif (tox='shedding') then
						sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaS_shed(h,tb,p)*activity_balances(tb,ah,p)*(ah in activitiesHour_electricity)]
					elseif (tox='demand_response') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='DR shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='storage') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='Storage')*(ah in activitiesHour_electricity)]
					elseif (tox='passive_storage') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*((tb)='BE shifting')*(ah in activitiesHour_electricity)]
					elseif (tox='smart_charging') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='EV smart charge')*(ah in activitiesHour_electricity)]
					elseif (tox='vehicle-to-grid') then
						-sum[(h,ah), (namePer_node(nodePer_techBal(tb))=nn)*
						PdeltaQ_UP(h,tb,p)*dQ_hourly(tb,ah)*(flexibilityType_tech(tb)='EV P-to-Grid')*(ah in activitiesHour_electricity)]
					elseif (tox='imports') then
						sum[(h,ahe), (namePer_node(nodePer_techBal(tb))=nn)*(nodePer_act(ahe)<>nodePer_techBal(tb))*
						(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
					elseif (tox='exports') then
						-sum[(h,ahe), (namePer_node(nodePer_act(ahe))=nn)*(nodePer_techBal(tb)<>nodePer_act(ahe))*
						(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
					elseif (tox='curtailment') then
						-sum[(h,ae), (namePer_node(nodePer_techBal(tb))=nn)*((labelPer_act(ae)='Wind')+(labelPer_act(ae)='Solar'))*
						(activity_balances(tb,ae,p)<0)*(Ptech_useHourlyNet(h,tb,p)-PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb)))]
						-sum[h, (namePer_node(nodePer_techBal(tb))=nn)*(StringOccurrences(profileType_tech(tb),"Hydro RoR")>0)*
						(Ptech_useHourlyNet(h,tb,p)-PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb)))]
					endif
				}
			}
			Parameter intTransport_indicators {
				IndexDomain: (toitr,p);
				Definition: {
					if (toitr = 'Emissions') then
						sum[t_c, (nodePer_techBal(t_c)='XX')*Ptech_useNet(t_c,p)]
					elseif (toitr = 'Shadow Price') then
						sum[ac, (nodePer_act(ac)='XX')*CO2_prices(ac,p)]
					endif
				}
			}
		}
		DeclarationSection Rounded_parameters {
			Parameter RSystemCosts_n {
				IndexDomain: (nn,toc,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_sec_n {
				IndexDomain: (nn,z,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter RSectoralConfiguration_stock {
				IndexDomain: (nn,z,as,tots,t,pnz);
				InitialData: 0;
			}
			Parameter RSectoralConfiguration_use {
				IndexDomain: (nn,z,as,tots,t,pnz);
				InitialData: 0;
			}
			Parameter RPower_stock {
				IndexDomain: (nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RPower_gen {
				IndexDomain: (nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RXC_stock {
				IndexDomain: (inn,nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RXC_use {
				IndexDomain: (inn,nn,tb,pnz);
				InitialData: 0;
			}
			Parameter RPower_dispatch {
				IndexDomain: (nn,h,th,pnz);
				InitialData: 0;
			}
			Parameter Remissions_all {
				IndexDomain: (nn,t_c,pnz);
				InitialData: 0;
			}
			Parameter Remissions_sec {
				IndexDomain: (nn,z,ac,pnz);
				InitialData: 0;
			}
			Parameter RsupdemAct_tech {
				IndexDomain: (nn,as,tob,tb,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_matrix {
				IndexDomain: (nn,z,tof,el,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_act {
				IndexDomain: (nn,z,as,pnz);
			}
			Parameter RprimaryBalance {
				IndexDomain: (nn,tope,el,pnz);
				InitialData: 0;
			}
			Parameter Rsankey_flows {
				IndexDomain: (nn,tou,itos,jtos,pnz);
				InitialData: 0;
			}
			Parameter RloadProfiles_H {
				IndexDomain: (nn,h,ah,pnz);
				InitialData: 0;
			}
			Parameter RflexProfiles_H {
				IndexDomain: (nn,topp,h,tb,pnz);
				InitialData: 0;
			}
			Parameter RloadProfiles_D {
				IndexDomain: (nn,d,ad,pnz);
				InitialData: 0;
			}
			Parameter RfinProfiles_D {
				IndexDomain: (nn,d,tg,pnz);
				InitialData: 0;
			}
			Parameter Rprofiles3D {
				IndexDomain: (nn,w,h_d,t3a,pnz);
				InitialData: 0;
			}
			Parameter Rfinal_decomposition {
				IndexDomain: (nn,tod,pnz);
				InitialData: 0;
			}
			Parameter RcurtailmentRES {
				IndexDomain: (nn,th,pnz);
				InitialData: 0;
			}
			Parameter Relectricity_parameters {
				IndexDomain: (nn,toep,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumes {
				IndexDomain: (nn,tox,pnz);
				InitialData: 0;
			}
			Parameter Rkey_indicators {
				IndexDomain: (nn,tok,pnz);
				InitialData: 0;
			}
			Parameter RLCOE {
				IndexDomain: (nn,as,tb,tolm,tol,pnz);
				InitialData: 0;
			}
			Parameter RSectoralCosts_cascade {
				IndexDomain: (nn,z,toc,pnz);
				InitialData: 0;
			}
			Parameter Rprimary_renewable {
				IndexDomain: (nn,el,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_sec_tot {
				IndexDomain: (nn,z,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_hourly {
				IndexDomain: (h,ah,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_nodeD {
				IndexDomain: (nn,d,ad,pnz);
				InitialData: 0;
			}
			Parameter RPlanningDecissions_tech {
				IndexDomain: (nn,t,topd,pnz);
				InitialData: 0;
			}
			Parameter RPowerInfo_act {
				IndexDomain: (ahee,topi,tb,pnz);
				InitialData: 0;
			}
			Parameter RXCinfo_act {
				IndexDomain: (iahee,ahee,topi,tb,pnz);
				InitialData: 0;
			}
			Parameter RintTransport_indicators {
				IndexDomain: (toitr,pnz);
				InitialData: 0;
			}
			Parameter REnergyCosts_node {
				IndexDomain: (nn,ae,pnz);
				InitialData: 0;
			}
			Parameter Rresidual_load {
				IndexDomain: (nn,h,torl,pnz);
				InitialData: 0;
			}
			Parameter RSystemCosts_act_n {
				IndexDomain: (nn,z,as,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter Remissions_act {
				IndexDomain: (nn,z,as,ac,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumesAct {
				IndexDomain: (nn,z,as,tox,pnz);
				InitialData: 0;
			}
			Parameter RfinalEnergy_matrixAct {
				IndexDomain: (nn,z,as,tof,el,pnz);
				InitialData: 0;
			}
			Parameter Rdecomposition_resLoad {
				IndexDomain: (nn,h,torlf,pnz);
				InitialData: 0;
			}
			Parameter Rdecomposition_resLoadY {
				IndexDomain: (nn,torlf,pnz);
				InitialData: 0;
			}
			Parameter Rflexibility_volumesTech {
				IndexDomain: (nn,tb,tox,pnz);
				InitialData: 0;
			}
			Parameter RenergyUse_act {
				IndexDomain: (nn,z,as,ae,pnz);
				InitialData: 0;
			}
			Parameter Remissions_tech {
				IndexDomain: (nn,z,as,tb,ac,pnz);
				InitialData: 0;
			}
			Parameter RLCOP_secE {
				IndexDomain: (nn,z,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter RLCOP_act {
				IndexDomain: (nn,z,as,tots,toc,pnz);
				InitialData: 0;
			}
			Parameter Rshadow_energyPrices {
				IndexDomain: (nn,ae,pnz);
				InitialData: 0;
			}
			Parameter Rshadow_CO2Prices {
				IndexDomain: (nn,ac,pnz);
				InitialData: 0;
			}
		}
		DeclarationSection Others {
			Parameter objFun_capCosts {
				IndexDomain: ps;
				Definition: {
					sum[(t,jp), InvMat_lifeTime(t,jp,ps)*
								(cap_investments(t,jp)*inv_cost(t,jp)*CRF(t)				!New invetments
								+sum[it, retrofitting(it,t,jp)*inv_cost(t,jp)*CRF(t)]			!Retroffiting aditions
								-sum[it, retrofitting(t,it,jp)*inv_cost(t,jp)*CRF(t)]			!Retrofitting substractions (yes, for the whole lifetime, as only the difference in cost is assumed to be paid)
								-eco_decommisioning(t,jp)*(1-decom_frac(t))*inv_cost(t,jp)*CRF(t)) 	!Recovered costs of decommisioning forwarded to the substitute investment
								]
				}
			}
			Parameter average_interconnectedPrice {
				IndexDomain: (ain,p);
				Definition: sum[h, interconnected_prices(h,ain,p)]/card(h);
			}
			Parameter objFun_operation {
				IndexDomain: ps;
				Definition: {
					sum[t, tech_use(t,ps)*(vom_cost(t,ps)+1e-6)] !Variable costs (including fuel costs)
					+sum[(h,thin), tech_useHourly(h,thin,ps)*(vom_hourly(h,thin,ps)+1e-16)]!Electricity costs of interconnected nodes
					+sum[(h,t), (deltaU_CHP(h,t,ps)+deltaS_shed(h,t,ps))*(vom_cost(t,ps)+1e-10)] !Deviations in tech use due to flexibility
					+sum[(t), techStock(t,ps)*fom_cost(t,ps)] !Fix costs
					+1e-6*sum[(h,tf), deltaQ_DW(h,tf,ps)-deltaQ_UP(h,tf,ps)] !To avoid multiple solutions
					+1e-6*sum[(h,ts), deltaS_shed(h,ts,ps)] !To avoid multiple solutions
				}
			}
			Parameter negEmissions_controller;
		}
		Procedure EnergyCosts_calculator {
			Body: {
				!Routine to get the fuel costs of energy production
				StatusMessage("Obtaining energy costs. . . " );
				
				!Delete the current values of energy_costs
				empty EnergyCosts,EnergyCosts_yearly,EnergyCosts_daily,EnergyCosts_hourly,techCosts_voc,IterCounter;
				
				
				!Energy costs based on (marginal) cost of generation technologies' SRMC
				while(IterCounter<5) do
					!Initialize by assigning primary costs
					techCosts_voc(h,tb,pnz) := vom_cost(tb,pnz)+vom_hourly(h,tb,pnz)
						+sum[ay, -activity_balances(tb,ay,pnz)*EnergyCosts_yearly(ay,pnz)*(activity_balances(tb,ay,pnz)<0)*TechExclussiveness(tb,pnz)] !For yearly activities
						+sum[ad, -activity_balances(tb,ad,pnz)*EnergyCosts_daily(dayPer_hour(h),ad,pnz)*(activity_balances(tb,ad,pnz)<0)*TechExclussiveness(tb,pnz)] !For daily activities
						+sum[ah, -activity_balances(tb,ah,pnz)*EnergyCosts_hourly(h,ah,pnz)*(activity_balances(tb,ah,pnz)<0)*TechExclussiveness(tb,pnz)] !For daily activities
						+sum[ac, -activity_balances(tb,ac,pnz)*EmissionCosts(ac,pnz)*(activityPer_tech(tb)<>ac)*TechExclussiveness(tb,pnz)]; !For emission costs
				
					!Obtain yearly energy costs for yearly energy activities
					EnergyCosts_yearly(ay,pnz) := (sum[tb, (activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)]>1e-2)*sum[(tb,h), 
						(activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)*techCosts_voc(h,tb,pnz)]/(sum[tb, (activityPer_tech(tb)=ay)*Ptech_useNet(tb,pnz)+1e-20]*card(hours));
				
					!Obtain daily energy costs for daily energy activities
					EnergyCosts_daily(d,ad,pnz) := sum[(tb,h), Ptech_useDailyNet(d,tb,pnz)*(activityPer_tech(tb)=ad)*(dayPer_hour(h)=d)/hoursPer_day*techCosts_voc(h,tb,pnz)]
					/sum[tb, Ptech_useDailyNet(d,tb,pnz)*(activityPer_tech(tb)=ad)+1e-20];
				
					!Obtain hourly energy costs for hourly energy activities
					EnergyCosts_hourly(h,ah,pnz) := max(tb,(Ptech_useHourlyNet(h,tb,pnz)>0.001)*(activityPer_tech(tb)=ah)*techCosts_voc(h,tb,pnz));
				
					!Obtain secondary activities cost assuming there shpuld only be yearly activities without a main technology
					EnergyCosts_yearly(ass,pnz) := (sum[tb,(activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)]>1e-2)*sum[(tb,h), 
						(activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)*techCosts_voc(h,tb,pnz)]/(sum[tb, (activity_balances(tb,ass,pnz)>0)*Ptech_useNet(tb,pnz)+1e-20]*card(hours));
				
					IterCounter := IterCounter + 1;
				endwhile;
				
				!Merge the costs
				if (EnergyPricesChoice = 'Marginal Costs') then 
					EnergyCosts(h,ae,pnz) := EnergyCosts_yearly(ae,pnz) + EnergyCosts_daily(dayPer_hour(h),ae,pnz) + EnergyCosts_hourly(h,ae,pnz);
				elseif (EnergyPricesChoice = 'Shadow Prices') then
					EnergyCosts(h,ae,pnz) := EnergyCosts_yearly(ae,pnz) + EnergyCosts_daily(dayPer_hour(h),ae,pnz) + hourly_prices(h,ae,pnz);
					EnergyCosts_hourly(h,ae,pnz) := hourly_prices(h,ae,pnz);
				endif;
				
				!Fix the zeros due to non-usage of primaries
				EnergyCosts(h,ae,pnz) := EnergyCosts(h,ae,pnz) + yearly_prices(ae,pnz)		
					*(EnergyCosts_yearly(ae,pnz)=0)*(((ae in activities_hour)+(ae in activities_day))=0);
				
				!!Fix the zeros due to non-usage of primaries
				!EnergyCosts(h,ae,pnz) := EnergyCosts(h,ae,pnz)
				!	+ sum[tb, (activityPer_tech(tb)=ae)*(tech_category(tb)='Primary')*(Ptech_useNet(tb,pnz)<1e-2)*vom_cost(tb,pnz)]
				!	*(EnergyCosts_yearly(ae,pnz)=0)*(((ae in activities_hour)+(ae in activities_day))=0);
				
				
				!Empty houry tech costs parameter to save memory
				empty techCosts_voc;
				
				StatusMessage("Energy costs were succesfully obtained. " );
			}
		}
		Procedure ObtainResidualLoad {
			Body: {
				!Routine to get all the elements of the residual load report
				StatusMessage("Obtaining the residual load elements. . . " );
				
				!Delete the current values of residual load
				empty residual_load;
				
				!{'Load (no flex)','Wind','Solar','Run of River','Residual Load','Imports','Exports','Shedding','CHPs UP','CHPs DW','Smart Charging UP',
				!'Smart Charging DW','V-to-G UP','V-to-G DW','Load Shifting UP','Load Shifting DW','Storage UP','Storage DW','Curtailment','Remaining'}
				
				residual_load(nn,h,torl,p) := (
				if (torl='Load (no flex)') then
					-sum[(ah,itb), IEM_node(nodePer_techBal(itb))*(namePer_node(nodePer_act(ah))=nn)*(namePer_node(nodePer_techBal(itb))=nn)*
						(activity_balances(itb,ah,p)<0)*(labelPer_act(ah)='Electricity')*(tech_subsector(itb)<>"XC Trade")*
						((itb in tech_shedding)=shedding_inLoad)* !This is to dissable shedding technologies from the accounting of res load, if we want to consider them we just need to comment the line
						activity_balances(itb,ah,p)*(
						Ptech_useHourly(h,itb,p) !Hourly dispatch units including transformers
						+Ptech_useDaily(dayPer_hour(h),itb,p)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
						+(PdeltaB_DW(dayPer_hour(h),itb,p)-PdeltaB_UP(dayPer_hour(h),itb,p))/hoursPer_day !Gas buffers consumption (asssuming flat hourly consumption of electricity)
						+Ptech_use(itb,p)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
					)]
					-sum[(ah,itb), IEM_node(nodePer_techBal(itb))*(namePer_node(nodePer_act(ah))=nn)*(namePer_node(nodePer_techBal(itb))=nn)*
						(labelPer_act(ah)='Electricity')*(tech_subsector(itb)="XC Trade")*(tech_category(itb)<>"Primary")*
						activity_balances(itb,ah,p)*Ptech_useHourly(h,itb,p) !Operation of all technologies
					]	
				elseif (torl='Wind') then
					-sum[(ae,tb), (labelPer_act(ae)='Wind')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
						PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb))]
				elseif (torl='Solar') then
					-sum[(ae,tb), (ae='Solar Energy')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
						PtechStock(tb,p)*cap2act(tb)*hourly_profiles(h,profileType_tech(tb))]
				elseif (torl='Run of River') then
					-sum[(ae,th), (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
						PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th))]
				elseif (torl='Baseload Generation') then
					-sum[(ae,th), (labelPer_act(ae)='Electricity')*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
						(ramping(th)<>0)*(ramping(th)<baseload_treshold)*(activity_balances(th,ae,p)>0)*
						Ptech_useHourly(h,th,p)*activity_balances(th,ae,p)]
				endif
				);
				
				!Obtain the residual load
				residual_load(nn,h,'Residual Load',p) := residual_load(nn,h,'Load (no flex)',p)+residual_load(nn,h,'Wind',p)+residual_load(nn,h,'Solar',p)
					+residual_load(nn,h,'Run of River',p)+residual_load(nn,h,'Baseload Generation',p);
				
				!Obtain differential residual load
				diferential_resLoad(nn,h,p) := (
				if (h<>1) then
					residual_load(nn,h,'Residual Load',p)-residual_load(nn,h-1,'Residual Load',p)
				elseif (h=1) then
					residual_load(nn,h,'Residual Load',p)-residual_load(nn,card(h),'Residual Load',p)
				endif
				);
				
				!Obtain decomposition residual load
				decomposition_resLoad(nn,h,torlf,p) := (
				if (torlf='Imports') then
					sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(nodePer_act(ahe)<>n)
					*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)]
				elseif (torlf='Exports') then
					sum[(n,tb,ahe), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_act(ahe)=n)*(nodePer_techBal(tb)<>n)
					*(activity_balances(tb,ahe,p)<0)*Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ahe,p)]
				elseif (torlf='Curtailment') then
					sum[(ae,th), (labelPer_act(ae)='Wind')*(activity_balances(th,ae,p)<0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					+sum[(ae,th), (labelPer_act(ae)='Solar')*(activity_balances(th,ae,p)<0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
					+sum[th, (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					(Ptech_useHourly(h,th,p)-PtechStock(th,p)*cap2act(th)*hourly_profiles(h,profileType_tech(th)))]
				elseif (torlf='Storage') then
					sum[(n,tfb),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfb)=n)*PdeltaQ_DW(h,tfb,p)]
					+sum[(n,tfb),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfb)=n)*PdeltaQ_UP(h,tfb,p)]
					+sum[(n,tfvg),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvg)=n)*PdeltaQ_DW(h,tfvg,p)]
					+sum[(n,tfvg),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvg)=n)*PdeltaQ_UP(h,tfvg,p)]
				elseif (torlf='Flex Generation') then
					sum[(n,ae,tb), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tb)=n)*(tech_subsector(tb)<>"XC Trade")
					*(labelPer_act(ae)='Electricity')*((ramping(tb)=0)+(ramping(tb)>baseload_treshold))*(activity_balances(tb,ae,p)>0)*
					Ptech_useHourlyNet(h,tb,p)*activity_balances(tb,ae,p)]
					+sum[(n,ah,tk), IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tk)=n)
					*PdeltaP_CHP(h,tk,p)*dP_electricity(tk,ah)] !Flexibility in Power/Heat range of CHP output
					-sum[(ae,tb), (labelPer_act(ae)='Wind')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
					Ptech_useHourlyNet(h,tb,p)]
					-sum[(ae,tb), (ae='Solar Energy')*(activity_balances(tb,ae,p)<0)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb))*
					Ptech_useHourlyNet(h,tb,p)]
					-sum[(ae,th), (StringOccurrences(profileType_tech(th),"Hydro RoR")>0)*(namePer_node(nodePer_techBal(th))=nn)*IEM_node(nodePer_techBal(th))*
					Ptech_useHourly(h,th,p)]
				elseif (torlf='Demand Response') then
					sum[(n,tfe),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfe)=n)*PdeltaQ_DW(h,tfe,p)]
					+sum[(n,tfe),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfe)=n)*PdeltaQ_UP(h,tfe,p)]
					+sum[(n,tfs),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfs)=n)*PdeltaQ_DW(h,tfs,p)]
					+sum[(n,tfs),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfs)=n)*PdeltaQ_UP(h,tfs,p)]
					+sum[(n,tfvc),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvc)=n)*PdeltaQ_DW(h,tfvc,p)]
					+sum[(n,tfvc),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(tfvc)=n)*PdeltaQ_UP(h,tfvc,p)]
					+(shedding_inLoad=0)*sum[(n,ahe,ts),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(ts)=n)*(nodePer_act(ahe)=n)*
					(Ptech_use(ts,p)*hourly_profiles(h,profileType_tech(ts))+PdeltaS_shed(h,ts,p))*activity_balances(ts,ahe,p)] !Shedded use of technologies
					+shedding_inLoad*sum[(n,ahe,ts),IEM_node(n)*(namePer_node(n)=nn)*(nodePer_techBal(ts)=n)*(nodePer_act(ahe)=n)*
					PdeltaS_shed(h,ts,p)*activity_balances(ts,ahe,p)] !Shedding of technologies
				endif
				);
				
				!Obtain the missing component
				decomposition_resLoad(nn,h,'Other',p) := residual_load(nn,h,'Residual Load',p) - sum[torlf, decomposition_resLoad(nn,h,torlf,p)];
				
				StatusMessage("Residual load parameters calculated. . . " );
			}
		}
		Procedure EmissionAdjustment {
			Body: {
				!File to adjust the emissions after the relaxation to allow for negative emissions
				
				!We substract the new relaxed target from the air released emission activities
				PtechStock(tb,pss) := PtechStock(tb,pss)-(activityPer_tech(tb) in activities_target)*roomFor_negative;
				Ptech_use(tb,pss) := Ptech_use(tb,pss)-(activityPer_tech(tb) in activities_target)*roomFor_negative;
			}
		}
		Procedure PostProcessParameters {
			Body: {
				StatusMessage("Post-processing parameters. . . " );
				!Delete the reporting parameters
				empty RSystemCosts_n, RSystemCosts_sec_n, RSectoralConfiguration_stock, RSectoralConfiguration_use, RPower_stock, RPower_gen, RXC_stock, RXC_use;
				empty Remissions_all,  Remissions_sec, RsupdemAct_tech, RfinalEnergy_matrix, RfinalEnergy_act, RprimaryBalance, Rsankey_flows, REnergyCosts_node;
				empty RPower_dispatch, RPowerInfo_act, RXCinfo_act, RloadProfiles_H, RflexProfiles_H, RloadProfiles_D, RfinProfiles_D, Rprofiles3D;
				empty Rfinal_decomposition, RcurtailmentRES, Relectricity_parameters, Rflexibility_volumes, Rkey_indicators, RLCOE, RSectoralCosts_cascade;
				empty RSystemCosts_sec_tot, Rprimary_renewable, REnergyCosts_hourly, REnergyCosts_nodeD, RPlanningDecissions_tech, RintTransport_indicators;
				empty REnergyCosts_node, Rresidual_load, RSystemCosts_act_n, Remissions_act, Rflexibility_volumesAct, RfinalEnergy_matrixAct, Rdecomposition_resLoad;
				empty Rdecomposition_resLoadY, Rflexibility_volumesTech, RenergyUse_act, Remissions_tech, RLCOP_secE, RLCOP_act, Rshadow_energyPrices;
				empty Rshadow_CO2Prices;
				
				!Assign post-processed parameters
				RSystemCosts_n(nn,toc,pnz) := SystemCosts_n(nn,toc,pnz);
				RSystemCosts_sec_n(nn,z,tots,toc,pnz) := SystemCosts_sec_n(nn,z,tots,toc,pnz);
				RSectoralConfiguration_stock(nn,z,as,tots,t,pnz) := SectoralConfiguration_stock(nn,z,as,tots,t,pnz);
				RSectoralConfiguration_use(nn,z,as,tots,t,pnz) := SectoralConfiguration_use(nn,z,as,tots,t,pnz);
				RPower_stock(nn,tb,pnz) := Power_stock(nn,tb,pnz);
				RPower_gen(nn,tb,pnz) := Power_gen(nn,tb,pnz);
				RXC_stock(inn,nn,tb,pnz) := XC_stock(inn,nn,tb,pnz);
				RXC_use(inn,nn,tb,pnz) := XC_use(inn,nn,tb,pnz);
				Remissions_all(nn,t_c,pnz) := emissions_all(nn,t_c,pnz);
				Remissions_sec(nn,z,ac,pnz) := emissions_sec(nn,z,ac,pnz);
				RsupdemAct_tech(nn,as,tob,tb,pnz) := supdemAct_tech(nn,as,tob,tb,pnz);
				RfinalEnergy_matrix(nn,z,tof,el,pnz) := finalEnergy_matrix(nn,z,tof,el,pnz);
				RfinalEnergy_act(nn,z,as,pnz) := finalEnergy_act(nn,z,as,pnz);
				RprimaryBalance(nn,tope,el,pnz) := primaryBalance(nn,tope,el,pnz);
				Rsankey_flows(nn,tou,itos,jtos,pnz) := sankey_flows(nn,tou,itos,jtos,pnz);
				Rfinal_decomposition(nn,tod,pnz) := final_decomposition(nn,tod,pnz);
				RcurtailmentRES(nn,th,pnz) := curtailmentRES(nn,th,pnz);
				Relectricity_parameters(nn,toep,pnz) := electricity_parameters(nn,toep,pnz);
				Rflexibility_volumes(nn,tox,pnz) := flexibility_volumes(nn,tox,pnz);
				Rkey_indicators(nn,tok,pnz) := key_indicators(nn,tok,pnz);
				RLCOE(nn,as,tb,tolm,tol,pnz) := LCOE(nn,as,tb,tolm,tol,pnz);
				RSectoralCosts_cascade(nn,z,toc,pnz) := SectoralCosts_cascade(nn,z,toc,pnz);
				RSystemCosts_sec_tot(nn,z,pnz) := SystemCosts_sec_tot(nn,z,pnz);
				Rprimary_renewable(nn,el,pnz) := primary_renewable(nn,el,pnz);
				RPlanningDecissions_tech(nn,t,topd,pnz) := PlanningDecisions_tech(nn,t,topd,pnz);
				RPowerInfo_act(ahee,topi,tb,pnz) := PowerInfo_act(ahee,topi,tb,pnz);
				RXCinfo_act(iahee,ahee,topi,tb,pnz) := XCinfo_act(iahee,ahee,topi,tb,pnz);
				RintTransport_indicators(toitr,pnz) := intTransport_indicators(toitr,pnz);
				REnergyCosts_node(nn,ae,pnz) := EnergyCosts_node(nn,ae,pnz);
				RSystemCosts_act_n(nn,z,as,tots,toc,pnz) := SystemCosts_act_n(nn,z,as,tots,toc,pnz);
				Remissions_act(nn,z,as,ac,pnz) := emissions_act(nn,z,as,ac,pnz);
				Rflexibility_volumesAct(nn,z,as,tox,pnz) := flexibility_volumesAct(nn,z,as,tox,pnz);
				RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz) := finalEnergy_matrixAct(nn,z,as,tof,el,pnz);
				Rflexibility_volumesTech(nn,tb,tox,pnz) := flexibility_volumesTech(nn,tb,tox,pnz);
				RenergyUse_act(nn,z,as,ae,pnz) := energyUse_act(nn,z,as,ae,pnz);
				Remissions_tech(nn,z,as,tb,ac,pnz) := emissions_tech(nn,z,as,tb,ac,pnz);
				RLCOP_secE(nn,z,tots,toc,pnz) := LCOP_secE(nn,z,tots,toc,pnz);
				RLCOP_act(nn,z,as,tots,toc,pnz) := LCOP_act(nn,z,as,tots,toc,pnz);
				Rshadow_energyPrices(nn,ae,pnz) := shadow_energyPrices(nn,ae,pnz);
				Rshadow_CO2Prices(nn,ac,pnz) := shadow_CO2Prices(nn,ac,pnz);
				
				!If hourly reports are required
				if (HourlyReportValue = 'yes') then
					StatusMessage("Post-processing hourly profiles . . . " );
					!Calculate the parameters
					Power_dispatch(nn,h,tb,p) := (labelPer_act(activityPer_tech(tb))='Electricity')*Ptech_useHourlyNet(h,tb,p)*(namePer_node(nodePer_techBal(tb))=nn)*IEM_node(nodePer_techBal(tb));
					loadProfiles_H(nn,h,ah,p) := (namePer_node(nodePer_act(ah))=nn)*(
						sum[itb | activity_balances(itb,ah,p)<0, activity_balances(itb,ah,p)*(
						Ptech_useHourly(h,itb,p) !Hourly dispatch units
						+Ptech_useDaily(dayPer_hour(h),itb,p)/hoursPer_day !Daily dispatch units (asssuming flat daily consumption of electricity)
						+(PdeltaB_DW(dayPer_hour(h),itb,p)-PdeltaB_UP(dayPer_hour(h),itb,p))/hoursPer_day !Gas buffers consumption (asssuming flat hourly consumption of electricity)
						+Ptech_use(itb,p)*hourly_profiles(h,profileType_tech(itb))  !Operation of all technologies
						+PdeltaS_shed(h,itb,p))] !Shedding
						+sum[tf, (PdeltaQ_UP(h,tf,p)+PdeltaQ_DW(h,tf,p)*(1-(tf in tech_fStorage)))*dQ_hourly(tf,ah)] !Upwards response of flexible technologies
					);
					refProfiles_H(nn,h,tb,p) :=-Ptech_use(tb,p)*hourly_profiles(h,profileType_tech(tb))*(namePer_node(nodePer_techBal(tb))=nn)*(		
						sum[ah | dQ_hourly(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, -PdeltaQ_UP(ih,tb,p)+PdeltaQ_DW(ih,tb,p)]>0) !Felxible technologies
						+sum[ah | dS_hourly(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, -PdeltaS_shed(ih,tb,p)]>0) !Shedding technologies
						-sum[ah | dP_electricity(tb,ah)=1, activity_balances(tb,ah,p)]*(sum[ih, PdeltaU_CHP(ih,tb,p)+PdeltaP_CHP(ih,tb,p)]<>0) !Flexible CHPs
					);
					finProfiles_H(nn,h,tb,p) :=(namePer_node(nodePer_techBal(tb))=nn)*(refProfiles_H(nn,h,tb,p)+
						(-PdeltaQ_UP(h,tb,p)-PdeltaQ_DW(h,tb,p))*(sum[ih, -PdeltaQ_UP(ih,tb,p)+PdeltaQ_DW(ih,tb,p)]>0) !Felxible technologies
						-sum[ah | dS_hourly(tb,ah)=1, PdeltaS_shed(h,tb,p)*activity_balances(tb,ah,p)]*(sum[ih, -PdeltaS_shed(ih,tb,p)]>0)!Shedding technologies
						-sum[ah | dP_electricity(tb,ah)=1, (PdeltaU_CHP(h,tb,p)*activity_balances(tb,ah,p)+PdeltaP_CHP(h,tb,p)*dP_electricity(tb,ah))]*(sum[ih, PdeltaU_CHP(ih,tb,p)+PdeltaP_CHP(ih,tb,p)]<>0) !Flexible CHPs
					);
					StatusMessage("Still doing hourly post-processing, be patient . . . " );
					flexProfiles_H(nn,'Reference',h,tb,p) := refProfiles_H(nn,h,tb,p);
					flexProfiles_H(nn,'Final',h,tb,p) := finProfiles_H(nn,h,tb,p);
					loadProfiles_D(nn,d,ad,p) := (namePer_node(nodePer_act(ad))=nn)*(
						sum[itb | activity_balances(itb,ad,p)<0, activity_balances(itb,ad,p)* !Only account for the demand
						(Ptech_useDaily(d,itb,p) !Daily dispatch units
						+sum[ih | dayPer_hour(ih)=d, Ptech_useHourly(ih,itb,p) !Hourly dispatch units
						+deltaB_DW(d,itb,p)-deltaB_UP(d,itb,p) !Gas buffers consumption 
						+hourly_profiles(ih,profileType_tech(itb))*
						(Ptech_use(itb,p) !Operation of non dispatchable technologies
						+PdeltaU_CHP(ih,itb,p) !Operation of flexible CHPs
						+PdeltaS_shed(ih,itb,p))])] !Operation of shedding technologies
						+sum[tg, PdeltaB_UP(d,tg,p)*dB_daily(tg,ad)] !Daily buffer units
					);
					refProfiles_D(nn,d,tg,p) := -Ptech_use(tg,p)*(namePer_node(nodePer_techBal(tg))=nn)*
						sum[ad | dB_daily(tg,ad)=1, activity_balances(tg,ad,p)]*sum[ih | dayPer_hour(ih)=d, hourly_profiles(ih,profileType_tech(tg))];
					finProfiles_D(nn,d,tg,p) := (namePer_node(nodePer_techBal(tg))=nn)*(refProfiles_D(nn,d,tg,p)-PdeltaB_UP(d,tg,p)-PdeltaB_DW(d,tg,p));
					profiles3D(nn,w,h_d,t3a,p) := 
						(t3a in activities_hour)
						*(namePer_node(nodePer_act(t3a))=nn)*sum[ih, loadProfiles_H(nn,ih,t3a,p)*(weekPer_hour(ih)=w)*(hoursindayPer_hour(ih)=h_d)]/7
						+((t3a in activities_hour)=0)	
						*(namePer_node(nodePer_act(t3a))=nn)*sum[(ih,th), Ptech_useHourlyNet(ih,th,p)*activity_balances(th,t3a,p)*(weekPer_hour(ih)=w)*(hoursindayPer_hour(ih)=h_d)]/7;
					StatusMessage("Obtaining residual load, be patient. . . " );
					ObtainResidualLoad;	
				
					!Report the parameters
					RPower_dispatch(nn,h,tb,pnz) := Power_dispatch(nn,h,tb,pnz);
					RloadProfiles_H(nn,h,ah,pnz) := loadProfiles_H(nn,h,ah,pnz);
					RflexProfiles_H(nn,topp,h,tb,pnz) := flexProfiles_H(nn,topp,h,tb,pnz);
					RloadProfiles_D(nn,d,ad,pnz) := loadProfiles_D(nn,d,ad,pnz);
					RfinProfiles_D(nn,d,tg,pnz) := finProfiles_D(nn,d,tg,pnz);
					Rprofiles3D(nn,w,h_d,t3a,pnz) := profiles3D(nn,w,h_d,t3a,pnz);
					REnergyCosts_hourly(h,ah,pnz) := EnergyCosts_hourly(h,ah,pnz);
					REnergyCosts_nodeD(nn,d,ad,pnz) := EnergyCosts_nodeD(nn,d,ad,pnz);
					Rresidual_load(nn,h,torl,pnz) := residual_load(nn,h,torl,pnz);
					Rkey_indicators(nn,tok,pnz) := key_indicators(nn,tok,pnz);
					Rdecomposition_resLoad(nn,h,torlf,pnz) := decomposition_resLoad(nn,h,torlf,pnz); 
					Rdecomposition_resLoadY(nn,torlf,pnz) := decomposition_resLoadY(nn,torlf,pnz); 
				endif;
				
				
				StatusMessage("Parameters were succesfully processed" );
			}
		}
		Procedure RoundParameters {
			Body: {
				StatusMessage("Rounding the results . . . " );
				
				!Rounding parameters to be reported
				RSystemCosts_n(nn,toc,pnz) := round(RSystemCosts_n(nn,toc,pnz),2);
				RSystemCosts_sec_n(nn,z,tots,toc,pnz) := round(RSystemCosts_sec_n(nn,z,tots,toc,pnz),2);
				RSectoralConfiguration_stock(nn,z,as,tots,t,pnz) := round(RSectoralConfiguration_stock(nn,z,as,tots,t,pnz),4);
				RSectoralConfiguration_use(nn,z,as,tots,t,pnz) := round(RSectoralConfiguration_use(nn,z,as,tots,t,pnz),3);
				RPower_stock(nn,tb,pnz) := round(RPower_stock(nn,tb,pnz),2);
				RPower_gen(nn,tb,pnz) := round(RPower_gen(nn,tb,pnz),2);
				RXC_stock(inn,nn,tb,pnz) := round(RXC_stock(inn,nn,tb,pnz),2);
				RXC_use(inn,nn,tb,pnz) := round(RXC_use(inn,nn,tb,pnz),2);
				Remissions_all(nn,t_c,pnz) := round(Remissions_all(nn,t_c,pnz),2);
				Remissions_sec(nn,z,ac,pnz) := round(Remissions_sec(nn,z,ac,pnz),2);
				RsupdemAct_tech(nn,as,tob,tb,pnz) := round(RsupdemAct_tech(nn,as,tob,tb,pnz),2);
				RfinalEnergy_matrix(nn,z,tof,el,pnz) := round(RfinalEnergy_matrix(nn,z,tof,el,pnz),2);
				RfinalEnergy_act(nn,z,as,pnz) := round(RfinalEnergy_act(nn,z,as,pnz),2);
				RprimaryBalance(nn,tope,el,pnz) := round(RprimaryBalance(nn,tope,el,pnz),2);
				Rsankey_flows(nn,tou,itos,jtos,pnz) := round(Rsankey_flows(nn,tou,itos,jtos,pnz),2);
				Rfinal_decomposition(nn,tod,pnz) := round(Rfinal_decomposition(nn,tod,pnz),2);
				RcurtailmentRES(nn,th,pnz) := round(RcurtailmentRES(nn,th,pnz),2);
				Relectricity_parameters(nn,toep,pnz) := round(Relectricity_parameters(nn,toep,pnz),2);
				Rflexibility_volumes(nn,tox,pnz) := round(Rflexibility_volumes(nn,tox,pnz),2);
				Rkey_indicators(nn,tok,pnz) := round(Rkey_indicators(nn,tok,pnz),2);
				RLCOE(nn,as,tb,tolm,tol,pnz) := round(RLCOE(nn,as,tb,tolm,tol,pnz),2);
				RSectoralCosts_cascade(nn,z,toc,pnz) := round(RSectoralCosts_cascade(nn,z,toc,pnz),2);
				RSystemCosts_sec_tot(nn,z,pnz) := round(RSystemCosts_sec_tot(nn,z,pnz),2);
				Rprimary_renewable(nn,el,pnz) := round(Rprimary_renewable(nn,el,pnz),2);
				RPlanningDecissions_tech(nn,t,topd,pnz) := round(RPlanningDecissions_tech(nn,t,topd,pnz),2);
				RPowerInfo_act(ahee,topi,tb,pnz) := round(RPowerInfo_act(ahee,topi,tb,pnz),2);
				RXCinfo_act(iahee,ahee,topi,tb,pnz) := round(RXCinfo_act(iahee,ahee,topi,tb,pnz),2);
				RintTransport_indicators(toitr,pnz) := round(RintTransport_indicators(toitr,pnz),2);
				REnergyCosts_node(nn,ae,pnz) := round(REnergyCosts_node(nn,ae,pnz),2);
				RSystemCosts_act_n(nn,z,as,tots,toc,pnz) := round(RSystemCosts_act_n(nn,z,as,tots,toc,pnz),2);
				Remissions_act(nn,z,as,ac,pnz) := round(Remissions_act(nn,z,as,ac,pnz),2);
				Rflexibility_volumesAct(nn,z,as,tox,pnz) := round(Rflexibility_volumesAct(nn,z,as,tox,pnz),2);
				RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz) := round(RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz),2);
				Rdecomposition_resLoadY(nn,torlf,pnz) := round(Rdecomposition_resLoadY(nn,torlf,pnz),2);
				Rflexibility_volumesTech(nn,tb,tox,pnz) := round(Rflexibility_volumesTech(nn,tb,tox,pnz),2);
				RenergyUse_act(nn,z,as,ae,pnz) := round(RenergyUse_act(nn,z,as,ae,pnz),2);
				Remissions_tech(nn,z,as,tb,ac,pnz) := round(Remissions_tech(nn,z,as,tb,ac,pnz),2);
				RLCOP_secE(nn,z,tots,toc,pnz) := round(RLCOP_secE(nn,z,tots,toc,pnz),2);
				RLCOP_act(nn,z,as,tots,toc,pnz) := round(RLCOP_act(nn,z,as,tots,toc,pnz),2);
				Rshadow_energyPrices(nn,ae,pnz) := round(Rshadow_energyPrices(nn,ae,pnz),2);
				Rshadow_CO2Prices(nn,ac,pnz) := round(Rshadow_CO2Prices(nn,ac,pnz),2);
				
				!If hourly reports are required
				if (HourlyReportValue = 'yes') then
					RPower_dispatch(nn,h,tb,pnz) := round(RPower_dispatch(nn,h,tb,pnz),8);
					RloadProfiles_H(nn,h,ah,pnz) := round(RloadProfiles_H(nn,h,ah,pnz),8);
					RflexProfiles_H(nn,topp,h,tb,pnz) := round(RflexProfiles_H(nn,topp,h,tb,pnz),8);
					RloadProfiles_D(nn,d,ad,pnz) := round(RloadProfiles_D(nn,d,ad,pnz),8);
					RfinProfiles_D(nn,d,tg,pnz) := round(RfinProfiles_D(nn,d,tg,pnz),8);
					Rprofiles3D(nn,w,h_d,t3a,pnz) := round(Rprofiles3D(nn,w,h_d,t3a,pnz),4);
					REnergyCosts_hourly(h,ah,pnz) := round(REnergyCosts_hourly(h,ah,pnz),2);
					REnergyCosts_nodeD(nn,d,ad,pnz) := round(REnergyCosts_nodeD(nn,d,ad,pnz),2);
					Rresidual_load(nn,h,torl,pnz) := round(Rresidual_load(nn,h,torl,pnz),8);
					Rdecomposition_resLoad(nn,h,torlf,pnz) := round(Rdecomposition_resLoad(nn,h,torlf,pnz),8);
				endif;
				
				StatusMessage("Results were rounded. " );
			}
		}
		Procedure PostProcess_andWrite {
			Body: {
				StatusMessage("Post-process parameters . . . " );
				!Post process parameters
				PostProcessParameters;
				
				StatusMessage("Rounding parameters . . . " );
				!Round parameters
				RoundParameters;
				
				! Creat a directory for Output files
				if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
				
				!Save the case
				StatusMessage("Saving the case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
				
				StatusMessage("Saving excel files . . . " );
				!Write the output
				runDataWritingTransition;
				
				!Play the alarm
				AIMMSWav(Signal);
				
				StatusMessage("Post-process and write is finished. " );
			}
		}
	}
	Section User_Interface {
		DeclarationSection UI_declaration {
			StringParameter project_name {
				InitialData: "update project name";
			}
			Set periods_window {
				SubsetOf: periods_selection;
			}
			Set periods_nonzeros {
				SubsetOf: periods;
				Index: pnz, ipnz;
				Definition: {
					{p | sum[t, Ptech_use(t,p)]>0}
				}
			}
			Set OutputFolderOptions {
				Index: ofo;
				Definition: {
					{'automatic','custom'}
				}
			}
			Set EnergyPricesOptions {
				OrderBy: User;
				Definition: data {'Shadow Prices' ,'Marginal Costs'};
			}
			Set RobustOptions {
				Index: oro;
				Definition: {
					{'yes','no'}
				}
			}
			Set YesNoOptions {
				Index: opo;
				Definition: {
					{'yes','no'}
				}
			}
			Set DataCasesSet;
			Set InputFilesSet {
				Index: fs, ifs, jfs;
			}
			Set InputFIlesSelection {
				SubsetOf: InputFilesSet;
			}
			Set IntrayearOptions {
				Index: oiy;
				Definition: {
					{'Pstock','min-max'}
				}
			}
			Set ObjFunOptions {
				Index: offo, ioffo, joffo;
				Definition: {
					{'IESA-Opt v4.2','IESA-Opt v4.3', 'IESA-Opt N'}
				}
			}
			ElementParameter OutputFolderValue {
				Range: OutputFolderOptions;
				InitialData: 'automatic';
			}
			ElementParameter RobustValue {
				Range: RobustOptions;
				InitialData: 'yes';
			}
			ElementParameter PricesValue {
				Range: YesNoOptions;
				InitialData: 'no';
			}
			ElementParameter ScaleValue {
				Range: YesNoOptions;
				InitialData: 'yes';
			}
			ElementParameter IntrayearValue {
				Range: IntrayearOptions;
				InitialData: 'Pstock';
			}
			ElementParameter ObjFunValue {
				Range: ObjFunOptions;
				InitialData: 'IESA-Opt v4.3';
			}
			ElementParameter Ref2020Value {
				Range: YesNoOptions;
				InitialData: 'no';
			}
			ElementParameter DataCaseLocation {
				Range: DataCasesSet;
			}
			ElementParameter DataReadingLocation {
				Range: InputFilesSet;
			}
			ElementParameter crossover_enabling {
				Range: YesNoOptions;
				InitialData: 'yes';
			}
			ElementParameter HourlyReportValue {
				Range: YesNoOptions;
				InitialData: 'no';
			}
			ElementParameter SaveCaseValue {
				Range: YesNoOptions;
				InitialData: 'no';
			}
			StringParameter OutputFolderName;
			StringParameter OutputFolderPrefix;
			ElementParameter EnergyPricesChoice {
				Range: EnergyPricesOptions;
				InitialData: 'Marginal Costs';
			}
			ElementParameter SolverChoiceTransition {
				Range: AllSolvers;
				InitialData: 'CPLEX 22.1';
			}
			ElementParameter SolverChoiceIYP {
				Range: AllSolvers;
				InitialData: 'CPLEX 22.1';
			}
			Parameter CPUCores {
				Range: {
					{0..NumCPU}
				}
				InitialData: 0;
			}
			Parameter OutputName_Hide {
				Range: binary;
				Definition: OutputFolderValue='automatic';
			}
			Parameter BS_counter {
				InitialData: 0;
			}
			Parameter BS_length {
				Definition: card(InputFIlesSelection);
			}
			Parameter ReadButton_Hide {
				Range: binary;
				InitialData: 0;
			}
			Parameter RunButton_Hide {
				Range: binary;
				InitialData: 1;
			}
			Parameter minmaxTol_Hide {
				Definition: IntrayearValue<>'min-max';
			}
			Parameter Ref2020_Exist {
				Range: binary;
				Definition: {
					if('Output\\REF2020\\REF2020.data' in DataCasesSet) then
						1
					else
						0
					endif
				}
			}
			Parameter Ref2020_Hide {
				Range: binary;
				Definition: 1-Ref2020_Exist;
			}
			Parameter Ref2020No_Hide {
				Range: binary;
			}
		}
		Procedure RetreiveExistingInputFiles {
			Body: {
				
				StatusMessage("Retreiving existing input files . . . " );
				
				!Clean the input set
				empty InputFilesSet;
				
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Extract the list of output data cases files
				DirectoryGetFiles("data\\","*.xlsx",InputScenarios);
				
				!Extract the list of output data cases files
				for(ifd | ifd<=card(InputScenarios) and ifd>0) do
					InputFiles(ifd) := "data\\" + InputScenarios(ifd);
					InputFilesSet := InputFilesSet + StringToElement(InputFilesSet,InputFiles(ifd),1);
					InputFIlesSelection := InputFilesSet;
				endfor;
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter InputScenarios {
				IndexDomain: ifd;
			}
			StringParameter InputFiles {
				IndexDomain: ifd;
			}
		}
		Procedure RetreiveProjectName {
			Body: {
				!Clean the input set
				empty project_name;
				
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Extract the name of the aimms project file
				DirectoryGetFiles(CurrentDirectory,"*.aimms",project_name_temp);
				project_name := project_name_temp(1) - ".aimms";
				
				StatusMessage("Project name is upated" );
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter project_name_temp {
				IndexDomain: ifd;
			}
		}
		Procedure RetreiveExistingOutputFolders {
			Body: {
				StatusMessage("Retreiving existing output data cases . . ." );
				
				!Clean the cases set
				empty DataCasesSet;
				!Get current directory
				DirectoryGetCurrent(CurrentDirectory);
				
				!Get all the Output folders in the directory
				DirectoryGetSubdirectories(CurrentDirectory+"\\Output","",FilesInOutput);
				
				!Extract the list of output data cases files
				for(ifd | ifd<=card(FilesInOutput) and ifd>0) do
					DirectoryGetFiles("Output\\"+FilesInOutput(ifd),"*.data",DataCasesFiles);
					OutputCasesFiles(ifd) := "Output\\" + FilesInOutput(ifd) + "\\" + DataCasesFiles(1);
					DataCasesSet := DataCasesSet + StringToElement(DataCasesSet,OutputCasesFiles(ifd),1);
				endfor;
				
				StatusMessage("Ready!" );
			}
			StringParameter CurrentDirectory;
			Set IntegerFolderDirectory {
				SubsetOf: Integers;
				Index: ifd;
			}
			StringParameter FilesInOutput {
				IndexDomain: ifd;
			}
			StringParameter DataCasesFiles {
				IndexDomain: ifd;
			}
			StringParameter OutputCasesFiles {
				IndexDomain: ifd;
			}
		}
		Procedure ApplyProjectName {
			Body: {
				!File to change the project name when opening the model
				RetreiveProjectName;
				option project_title := project_name;
			}
		}
		Procedure Update_ipss {
			Body: {
				! Section to update the priod selection values in the intra-year solving to allow for sequential runs
				periods_selection := periods_nonzeros;
			}
		}
		Procedure REF2020_check {
			Body: {
				!Check if there is a version called REF2020, and if not then make read button visible
				RetreiveExistingOutputFolders;
				if (Ref2020_Exist<>1) then ReadButton_Hide := 0; endif;
			}
		}
	}
	Section Data_Exchange {
		DeclarationSection Error_handling {
			ElementParameter err {
				Range: errh::PendingErrors;
			}
		}
		Section Data_Reading {
			Procedure DataReading {
				Arguments: (FileLocation);
				Body: {
					!block 
					
										! Clear the parameters
										if (REF2020Value='no') then
											empty hours_orig, activities_original, tech_balancers, tech_infra, dispatch_type, activity_type;
											empty  process_type, profile_typeRead, flexibility_type, range_type, energy_labels, sectors, nodes, node_names;
										endif;
					
										empty dispatchType_act, activityType_act, activityPer_techOrig, processType_tech, profileType_techRead, flexibilityType_tech, interconnected_pricesOrig; 
										empty act_units, tech_name, tech_category, tech_sector, tech_subsector, tech_units, scenario_description, feedstockUse_techOrig;
										empty activities_netVolumesOrig, activity_balancesRef, activity_EffImprov, hourly_profilesReadOrig, monthPer_hourOrig, XC_TransmissionLoss, emissionTarget;
										empty emmisionTarget_bin, roomFor_negative, inv_cost, decom_frac, fom_cost, vom_cost, WACC, construction_time, ec_lifetime, tec_lifetime;
										empty cap2act, ramping, HVtoMV_TransformerLoss, MVtoLV_TransformerLoss, HVtoLV_TransformerLoss, infra_range, infra_activityOrig, techStock_bin;
										empty techStock_exist, decom_planned, techStock_min, techStock_max, flex_capacity, flex_losses, flex_storage, flex_range, flex_activityOrig, retro_cost;
										empty flex_nnLoad, avg_journey, avg_speed, buffer_activityOrig, bufferUP_capacity, bufferDW_capacity, buffer_storage, baseload_treshold, shedding_inLoad;
										empty namePer_node, IEM_node, IEM_sector, is_renewable, labelPer_act, actChange_maxOrig, techChange_max, phs_capacity, phs_storage ,phs_losses;
										empty CHP_prodOrig, CHP_fuelOrig, CHP_eta, CHP_range, CHPdev_use, CHPdev_PtoH, shed_capacity, shed_volume, shed_range, hybrid_substitute, hybrid_ratio; 
										empty cumulative_emissions, cumulative_CO2storage;
					
										! Open the workbook
										if axll::WorkBookIsOpen(FileLocation) then
										       axll::SelectWorkBook(FileLocation);
										else
										       axll::OpenWorkBook(FileLocation);
										endif;
					
										!Select the workbook sheet
										axll::SelectSheet("IESA-Opt database");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  scenario_description,
											Cell           		:  "E21");
					
										!Select the workbook sheet
										axll::SelectSheet("Parameters");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  roomFor_negative,
											Cell           		:  "B4");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  XC_TransmissionLoss,
											Cell           		:  "B5");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  baseload_treshold,
											Cell           		:  "B6");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  shedding_inLoad,
											Cell           		:  "B7");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  social_discount_rate,
											Cell           		:  "B12");
					
										!Read a scalar
										axll::ReadSingleValue(
											ScalarReference 	:  base_year,
											Cell           		:  "B13");
					
										!Select the workbook sheet
										axll::SelectSheet("Types");
										if (REF2020Value='no') then
											!Read the sets
											axll::ReadSet(
												SetReference    			:  dispatch_type,
												SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  activity_type,
												SetRange        			:  "B4:B8", !revised by Kira to include material conversion
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  process_type,
												SetRange        			:  "C4:C30",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  flexibility_type,
												SetRange        			:  "D4:D30",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  range_type,
												SetRange        			:  "E4:E12",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  sectors,
												SetRange        			:  "F4:F50",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  nodes,
												SetRange        			:  "H4:H50",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  node_names,
												SetRange        			:  "I4:I50",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  energy_labels,
												SetRange        			:  "K4:K50",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
										endif;
					
										!Read the data
										axll::ReadList(
										       IdentifierReference 		:  IEM_sector,
										       RowHeaderRange      		:  FormatString("F4:F%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("G4:G%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										axll::ReadList(
										       IdentifierReference 		:  namePer_node,
										       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("I4:I%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										axll::ReadList(
										       IdentifierReference 		:  IEM_node,
										       RowHeaderRange      		:  FormatString("H4:H%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("J4:J%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										axll::ReadList(
										       IdentifierReference 		:  is_renewable,
										       RowHeaderRange      		:  FormatString("K4:K%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("L4:L%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("NodeParameters");
					
										!Read the data
										axll::ReadList(
										       IdentifierReference 		:  cumulative_emissions,
										       RowHeaderRange      		:  FormatString("A4:A%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("B4:B%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										axll::ReadList(
										       IdentifierReference 		:  cumulative_CO2storage,
										       RowHeaderRange      		:  FormatString("A4:A%i",axll::LastUsedRowNumber),
										       DataRange        		:  FormatString("C4:C%i",axll::LastUsedRowNumber),
										       MergeWithExistingData		:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("Activities");
					
										if (REF2020Value='no') then
											!Read the sets
										!	axll::ReadSet(
										!		SetReference    			:  periods,
										!		SetRange        			:  "C3:I3",
										!		ExtendSuperSets 			:  1,
										!		MergeWithExistingElements		:  0,
										!		SkipEmptyCells				:  1);
					
											axll::ReadSet(
												SetReference    			:  activities_original,
												SetRange        			:  FormatString("A9:A%i",axll::LastUsedRowNumber),
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
										endif;
					
										!Read the data       
										axll::ReadList(
										       IdentifierReference 	:   act_units,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("B9:B%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:   actChange_maxOrig,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("J9:J%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:   dispatchType_act,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("K9:K%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:   activityType_act,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("L9:L%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  nodePer_act,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("M9:M%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  emmisionTarget_bin,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("N9:N%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  labelPer_act,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("O9:O%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  activities_netVolumesOrig,
										       RowHeaderRange      	:  FormatString("A9:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "C8:I8",
										       DataRange           	:  FormatString("C9:I%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("HourlyProfiles");
					
										axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
										!Read the sets
										if (REF2020Value='no') then
											axll::ReadSet(
												SetReference    			:  hours_orig,
												SetRange        			:  FormatString("A5:A%i",axll::LastUsedRowNumber),
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
										endif;
					
										axll::ReadSet(
										       SetReference    			:  profile_typeRead,
										       SetRange        			:  "D3:"+ColName+"3",
										       ExtendSuperSets 			:  1,
										       MergeWithExistingElements	:  0,
										       SkipEmptyCells			:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  monthPer_hourOrig,
										       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("C5:C%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  hourly_profilesReadOrig,
										       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "D3:"+ColName+"3",
										       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);       
					
										!Select the workbook sheet
										axll::SelectSheet("Technologies");
					
										!Read the sets
										if (REF2020Value='no') then
											axll::ReadSet(
												SetReference    			:  tech_balancers,
												SetRange        			:  FormatString("A7:A%i",axll::LastUsedRowNumber),
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
										endif;
					
										!Read tech info
					
										axll::ReadList(
										       IdentifierReference 	:  tech_category,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("B7:B%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_sector,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("C7:C%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_subsector,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("D7:D%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  activityPer_techOrig,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("E7:E%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_name,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("F7:F%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_units,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("G7:G%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										!Read the data
										axll::ReadTable(
										       IdentifierReference 	:  inv_cost,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "H4:N4",
										       DataRange           	:  FormatString("H7:N%i",axll::LastUsedRowNumber),,
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  decom_frac,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("O7:O%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  fom_cost,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "P4:V4",
										       DataRange           	:  FormatString("P7:V%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  vom_cost,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "W4:AC4",
										       DataRange           	:  FormatString("W7:AC%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  WACC,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AD7:AD%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  construction_time,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AE7:AE%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  ec_lifetime,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AF7:AF%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  tec_lifetime,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AG7:AG%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  cap2act,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AH7:AH%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  processType_tech,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AI7:AI%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  profileType_techRead,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AJ7:AJ%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  ramping,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AK7:AK%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHP_prodOrig,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AL7:AL%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHP_fuelOrig,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AM7:AM%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHP_eta,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AN7:AN%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHP_range,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AO7:AO%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHPdev_use,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AP7:AP%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  CHPdev_PtoH,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AQ7:AQ%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  shed_capacity,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AR7:AR%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  shed_volume,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AS7:AS%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  shed_range,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AT7:AT%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  phs_capacity,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AU7:AU%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  phs_storage,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AV7:AV%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  phs_losses,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AW7:AW%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flexibilityType_tech,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AX7:AX%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_activityOrig,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AY7:AY%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_capacity,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("AZ7:AZ%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_storage,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BA7:BA%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_range,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BB7:BB%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_losses,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BC7:BC%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  flex_nnLoad,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BD7:BD%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  avg_journey,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BE7:BE%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  avg_speed,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BF7:BF%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);       
					
										axll::ReadList(
										       IdentifierReference 	:  buffer_activityOrig,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BG7:BG%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  bufferUP_capacity,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BH7:BH%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  bufferDW_capacity,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BI7:BI%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  buffer_storage,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange        	:  FormatString("BJ7:BJ%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  techStock_bin,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("BK7:BK%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  techChange_max,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("BM7:BM%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  techStock_exist,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("BN7:BN%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  decom_planned,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "BO5:BT5",
										       DataRange           	:  FormatString("BO7:BT%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  techStock_min,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "BU5:CA5",
										       DataRange           	:  FormatString("BU7:CA%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  techStock_max,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "CB5:CH5",
										       DataRange           	:  FormatString("CB7:CH%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  no_eco_decom,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "CX5:DD5",
										       DataRange           	:  FormatString("CX7:DD%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadTable(
										       IdentifierReference 	:  no_new_invest,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "CQ5:CW5",
										       DataRange           	:  FormatString("CQ7:CW%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("EnergyBalance");
					
										axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
										axll::ReadTable(
										       IdentifierReference 	:  activity_balancesRef,
										       RowHeaderRange      	:  FormatString("A7:A%i",axll::LastUsedRowNumber),                                           
										       ColumnHeaderRange      	:  "O3:"+ColName+"3", 						 !!!!
										       DataRange           	:  "O7:"+ColName+FormatString("%i",axll::LastUsedRowNumber), 
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("Infrastructure");
					
										axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
										!Read the sets
										if (REF2020Value='no') then
											axll::ReadSet(
												SetReference    			:  tech_infra,
												SetRange        			:  "A6:A100",
												ExtendSuperSets 			:  1,
												MergeWithExistingElements		:  0,
												SkipEmptyCells				:  1);
										endif;
					
										!Include infra technologies into th set of technologies
										technologies := tech_balancers + tech_infra;
					
										!Read tech info
										axll::ReadList(
										       IdentifierReference 	:  tech_name,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("E6:E%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										!Read tech info
										axll::ReadList(
										       IdentifierReference 	:  tech_units,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("F6:F%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_category,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("B6:B%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_sector,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("C6:C%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  tech_subsector,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("D6:D%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										!Read the data
										axll::ReadTable(
										       IdentifierReference 	:  inv_cost,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "G4:M4",
										       DataRange           	:  FormatString("G6:M%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  decom_frac,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("N6:N%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadTable(
										       IdentifierReference 	:  fom_cost,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "O4:U4",
										       DataRange           	:  FormatString("O6:U%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  WACC,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("V6:V%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  ec_lifetime,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("W6:W%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  tec_lifetime,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("X6:X%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  cap2act,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("Y6:Y%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  infra_range,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("Z6:Z%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);       
					
										axll::ReadList(
										       IdentifierReference 	:  infra_activityOrig,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AA6:AA%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  techStock_bin,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AB6:AB%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  techChange_max,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AD6:AD%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  techStock_exist,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("AE6:AE%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadTable(
										       IdentifierReference 	:  decom_planned,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "AF3:AK3",
										       DataRange           	:  FormatString("AF6:AK%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadTable(
										       IdentifierReference 	:  techStock_min,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "AL3:AR3",
										       DataRange           	:  FormatString("AL6:AR%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										axll::ReadTable(
										       IdentifierReference 	:  techStock_max,
										       RowHeaderRange      	:  FormatString("A6:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "AS3:AY3",
										       DataRange           	:  FormatString("AS6:AY%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  1);
					
										!Select the workbook sheet
										axll::SelectSheet("PriceProfiles");
					
										axll::ColumnName(axll::LastUsedColumnNumber,ColName);
					
										axll::ReadTable(
										       IdentifierReference 	:  interconnected_pricesOrig,
										       RowHeaderRange      	:  FormatString("A5:A%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "D2:"+ColName+"3",
										       DataRange           	:  "D5:"+ColName+FormatString("%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);  
					
										!Select the workbook sheet
										axll::SelectSheet("ActGrouping");
					
										!Read the sets
										axll::ReadSet(
										       SetReference    			:  activities_group,
										       SetRange        			:  FormatString("A4:A%i",axll::LastUsedRowNumber),
										       ExtendSuperSets 			:  1,
										       MergeWithExistingElements	:  0,
										       SkipEmptyCells			:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  dispatchType_act,
										       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
										       DataRange           	:  FormatString("B4:B%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  activityType_act,
										       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
										       DataRange           	:  FormatString("C4:C%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  nodePer_act,
										       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
										       DataRange           	:  FormatString("D4:D%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  emmisionTarget_bin,
										       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
										       DataRange           	:  FormatString("E4:E%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  1);
					
										axll::ReadList(
										       IdentifierReference 	:  labelPer_act,
										       RowHeaderRange      	:  FormatString("A4:A%i",Max(axll::LastUsedRowNumber,4)),
										       DataRange           	:  FormatString("F4:F%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  1);
					
										!Read the data
										axll::ReadTable(
										       IdentifierReference 	:  groupOf_activities,
										       RowHeaderRange      	:  FormatString("H4:I%i",Max(axll::LastUsedRowNumber,4)),
										       ColumnHeaderRange      	:  "",
										       DataRange           	:  FormatString("J4:J%i",Max(axll::LastUsedRowNumber,4)),
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("EffLearning");
					
										axll::ReadTable(
										       IdentifierReference 	:  activity_EffImprov,
										       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
										       ColumnHeaderRange      	:  "E3:K3",
										       DataRange           	:  FormatString("E4:K%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("Feedstocks");
					
										axll::ReadList(
										       IdentifierReference 	:  feedstockUse_techOrig,
										       RowHeaderRange      	:  FormatString("C4:D%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("H4:H%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										!Select the workbook sheet
										axll::SelectSheet("Retrofitting");
					
										axll::ReadList(
										       IdentifierReference 	:  retrofit_relations,
										       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("F4:F%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::ReadList(
										       IdentifierReference 	:  retro_cost,
										       RowHeaderRange      	:  FormatString("A4:B%i",axll::LastUsedRowNumber),
										       DataRange           	:  FormatString("G4:G%i",axll::LastUsedRowNumber),
										       MergeWithExistingData	:  0);
					
										axll::CloseWorkBook(FileLocation);
					
										!onerror err do
										!
										!errh::MarkAsHandled(err , 1) ;
										!
										!endblock;
										!
				}
				StringParameter ColName;
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure runDataReading {
				Body: {
					!!Assign an input file manually if the UI is not used
					!DataReadingLocation := 'data\IntegratedEnergySystem_v36full'
					
					StatusMessage("Reading data file: " + DataReadingLocation);
					DataReading(DataReadingLocation);
					
					!Build the tech names set
					BuildTechNominals;
					
					!Expand set of everything
					set_of_everything := set_of_everything + {'Exports','Losses','Primary'};
					typesOf_sankeyElements := energy_labels - 'NA' + sectors + {'Exports','Losses','Primary'};
					
					!!!Define sets from reading of element parameters$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
					!Set of activities that are hourly constrained by infrastructure
					for (iti_h in tech_infraH) do
						act_infraH:=act_infraH+infra_activity(iti_h);
					endfor;
					!Set of activities that are daily constrained by infrastructure
					for (iti_d in tech_infraD) do
						act_infraD:=act_infraD+infra_activity(iti_d);
					endfor;
					
					!!!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
					!!!Correct for the enabling of negative emissions
					activities_netVolumesOrig(act,p) := activities_netVolumesOrig(act,p) + roomFor_negative; !We force the system to mitigate a certain ammount of emission
					!We add such enforced mitigation to the target
					emissionTarget(n,p) := sum[tb, (nodePer_act(activityPer_tech(tb))=n)*(activityPer_tech(tb) in activities_target)*techStock_max(tb,p)] 
					+ sum[act | nodePer_act(act)=n, activities_netVolumes(act,p)];
					emissionTarget_cum(n) := cumulative_emissions(n) + sum[act | nodePer_act(act)=n, roomFor_negative*transition_interval];
					
					!We relax the max stock constrain for such technologies with the new relaxed emission target
					for (jn in nodes) do
						techStock_max(tb,p) := 
						(1-(nodePer_act(activityPer_tech(tb))=jn)*(activityPer_tech(tb) in activities_target))*techStock_max(tb,p)
						+(nodePer_act(activityPer_tech(tb))=jn)*(activityPer_tech(tb) in activities_target)*emissionTarget(jn,p);
					endfor;
					!!!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
					
					StatusMessage("Finished reading the input data. The model is ready to run.");
				}
			}
			Procedure BuildTechNominals {
				Body: {
					! File to build the tech nominals set
					for(t in technologies) do
						tech_nominals := tech_nominals + StringToElement(tech_nominals,tech_name(t),1);
					endfor;
					StatusMessage("Tech nominals set built." );
				}
			}
		}
		Section Data_Writing {
			Procedure DataWriting_General {
				Arguments: (FileLocation);
				Body: {
					!Open the workbook
					if axll::WorkBookIsOpen(FileLocation) then
					       axll::SelectWorkBook(FileLocation);
					else
					       !Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "Key_Indicators"
						);
						!Creating sheets
						axll::CreateSheet(SheetName:"System_Costs");
						axll::CreateSheet(SheetName:"FinalSector_Costs");
						axll::CreateSheet(SheetName:"Sectoral_Costs");
						axll::CreateSheet(SheetName:"Activity_Costs");
						axll::CreateSheet(SheetName:"Sectoral_Cascade");
						axll::CreateSheet(SheetName:"Configuration_Stock");
						axll::CreateSheet(SheetName:"Configuration_Use");
						axll::CreateSheet(SheetName:"Planning_Decissions");
						axll::CreateSheet(SheetName:"FinalEnergy_Use");
						axll::CreateSheet(SheetName:"FinalEnergy_Activities");
						axll::CreateSheet(SheetName:"FinalEnergy_Matrix");
						axll::CreateSheet(SheetName:"EnergyUse_Activities");
						axll::CreateSheet(SheetName:"EnergyCosts");
						axll::CreateSheet(SheetName:"ShadowEnergyPrices");	
						axll::CreateSheet(SheetName:"ShadowCO2Prices");
						axll::CreateSheet(SheetName:"Primary_Balance");
						axll::CreateSheet(SheetName:"Primary_Renewable");
						axll::CreateSheet(SheetName:"Final_Decomposition");
						axll::CreateSheet(SheetName:"Sankey");
						axll::CreateSheet(SheetName:"SupplyDemand");
						axll::CreateSheet(SheetName:"CO2_Emissions");
						axll::CreateSheet(SheetName:"Sectoral_Emissions");
						axll::CreateSheet(SheetName:"Activity_Emissions");
						axll::CreateSheet(SheetName:"Technology_Emissions");
						axll::CreateSheet(SheetName:"Power_Stock");
						axll::CreateSheet(SheetName:"Power_Gen");
						axll::CreateSheet(SheetName:"XC_Stock");
						axll::CreateSheet(SheetName:"XC_Use");
						axll::CreateSheet(SheetName:"Power_EU");
						axll::CreateSheet(SheetName:"XC_EU");
						axll::CreateSheet(SheetName:"RES_Curtailment");
						axll::CreateSheet(SheetName:"Electricity_Parameters");
						axll::CreateSheet(SheetName:"Flexibility_Volumes");
						axll::CreateSheet(SheetName:"Flexibility_Activities");
						axll::CreateSheet(SheetName:"Flexibility_Technologies");
						axll::CreateSheet(SheetName:"ResLoad_Decomposition");
						axll::CreateSheet(SheetName:"LCOPs_Conversion");
						axll::CreateSheet(SheetName:"LCOPs_Activities");
						axll::CreateSheet(SheetName:"LCOEs");
						axll::CreateSheet(SheetName:"International_Transport");
						axll::CreateSheet(SheetName:"TechInfo");
						axll::CreateSheet(SheetName:"FlexInfo");
						!axll::CreateSheet(SheetName:"ActInfo");
						axll::CreateSheet(SheetName:"Scenario");
						axll::CreateSheet(SheetName:"MathProgram");
					endif;
					
					!-----------------------------------------------------------------------------------
					
					!Write the table: Key Indicators (node name, type of indicator, period)=================================================================================
					axll::SelectSheet("Key_Indicators");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rkey_indicators(nn,tok,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: System Cost (node name, type of cost, period)=================================================================================
					axll::SelectSheet("System_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_n(nn,toc,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table:  SystemCosts_sec_tot(node name, sector, period)=================================================================================
					axll::SelectSheet("FinalSector_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_sec_tot(nn,z,pnz),
					  RowHeaderRange : "A2:B100",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sectoral Cost (node name, sector, type of tech source, type of cost, period)==================================================
					axll::SelectSheet("Sectoral_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_sec_n(nn,z,tots,toc,pnz),
					  RowHeaderRange : "A2:D100",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Activity Cost (node name, sector, activity, type of tech source, type of cost, period)==================================================
					axll::SelectSheet("Activity_Costs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSystemCosts_act_n(nn,z,a,tots,toc,pnz),
					  RowHeaderRange : "A2:E100",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Sectoral Cost Cascade (node name, sector, type of cost, period)===============================================================
					axll::SelectSheet("Sectoral_Cascade");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralCosts_cascade(nn,z,toc,pnz),
					  RowHeaderRange : "A2:C100",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ100",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Configuration Stock (node name, sector, activity, type of source, technology, period)=========================================
					axll::SelectSheet("Configuration_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralConfiguration_stock(nn,z,as,tots,t,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Configuration Use (node name, sector, activity, type of source, technology, period)===========================================
					axll::SelectSheet("Configuration_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RSectoralConfiguration_use(nn,z,as,tots,t,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Planning Decissions (node name, technology, type of decission, period)===========================================
					axll::SelectSheet("Planning_Decissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPlanningDecissions_tech(nn,t,topd,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Final Energy Use (node name, sector, type of final, energy label, period)=====================================================
					axll::SelectSheet("FinalEnergy_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_matrix(nn,z,tof,el,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	: energy_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Final Energy Activities (node name, sector, activity, period)=================================================================
					axll::SelectSheet("FinalEnergy_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_act(nn,z,as,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Final Energy Matrix (node name, sector, activity, type, energy, period)=================================================================
					axll::SelectSheet("FinalEnergy_Matrix");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RfinalEnergy_matrixAct(nn,z,as,tof,el,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Energy Use Activities (node name, sector, activity, energy, period)=================================================================
					axll::SelectSheet("EnergyUse_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RenergyUse_act(nn,z,as,ae,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Energy Costs (node name, activity, period) (note from Kira: these are average hourly energy costs on an annual basis)=================================================================
					axll::SelectSheet("EnergyCosts");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : REnergyCosts_node(nn,ae,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Shadow Energy Prices (node name, activity, period)=================================================================
					axll::SelectSheet("ShadowEnergyPrices");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rshadow_energyPrices(nn,ae,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Shadow CO2 Prices (node name, activity, period)=================================================================
					axll::SelectSheet("ShadowCO2Prices");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rshadow_CO2Prices(nn,ac,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Primary Balance (node name, type of primary, energy label,  period)===========================================================
					axll::SelectSheet("Primary_Balance");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RprimaryBalance(nn,tope,el,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Primary Renewable (node name, energy label,  period)===========================================================
					axll::SelectSheet("Primary_Renewable");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rprimary_renewable(nn,el,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Energy
					axll:: WriteSingleValue(
						ScalarReference 	:  energy_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Final Decomposition (node name, type of decomposition,  period)===============================================================
					axll::SelectSheet("Final_Decomposition");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rfinal_decomposition(nn,tod,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sankey Flows (node name, type of use, source, sink,  period)===========================================================
					axll::SelectSheet("Sankey");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rsankey_flows(nn,tou,itos,jtos,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Source
					axll:: WriteSingleValue(
						ScalarReference 	:  source_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Sink
					axll:: WriteSingleValue(
						ScalarReference 	:  sink_string,
						Cell           		:  "D1"
					);
					
					!Write the table: SupplyDemand (node name, activity, type of balance, technology, period)=======================================================
					axll::SelectSheet("SupplyDemand");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RsupdemAct_tech(nn,as,tob,tb,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	: type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "D1"
					);
					
					!Write the table: CO2 emissions (node name, technology, period)=================================================================================
					axll::SelectSheet("CO2_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_all(nn,t_c,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Sectoral emissions (node name, sector, activity, period)======================================================================
					axll::SelectSheet("Sectoral_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_sec(nn,z,ac,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Activity emissions (node name, sector, activity, activity, period)======================================================================
					axll::SelectSheet("Activity_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_act(nn,z,as,ac,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Technology emissions (node name, sector, activity,, technology, activity, period)======================================================================
					axll::SelectSheet("Technology_Emissions");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Remissions_tech(nn,z,as,tb,ac,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Actvity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Technology
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Power Stock(node name,technology, period)=====================================================================================
					axll::SelectSheet("Power_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPower_stock(nn,tb,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Power Gen(node name,technology, period)=======================================================================================
					axll::SelectSheet("Power_Gen");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPower_gen(nn,tb,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: XC Stock(source,node,technology, period)======================================================================================
					axll::SelectSheet("XC_Stock");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXC_stock(inn,nn,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: XC Use(source,node name,technology, period)===================================================================================
					axll::SelectSheet("XC_Use");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXC_use(inn,nn,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: Power EU(activity,type,technology,period)===================================================================================
					axll::SelectSheet("Power_EU");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RPowerInfo_act(ahee,topi,tb,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "C1"
					);
					
					!Write the table: XC EU(source,activity,type,technology,period)===================================================================================
					axll::SelectSheet("XC_EU");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RXCinfo_act(iahee,ahee,topi,tb,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: From
					axll:: WriteSingleValue(
						ScalarReference 	:  from_string,
						Cell           		:  "A1"
					);
					!Write the parameter: To
					axll:: WriteSingleValue(
						ScalarReference 	:  to_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "D1"
					);
					
					!Write the table: RES curtailment(node, technology, period)=====================================================================================
					axll::SelectSheet("RES_Curtailment");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RcurtailmentRES(nn,th,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	: techID_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Electricity Parameters(node, type, period)====================================================================================
					axll::SelectSheet("Electricity_Parameters");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Relectricity_parameters(nn,toep,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Flexibility Volumes(node, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Volumes");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumes(nn,tox,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: Flexibility Activities(node, sector, activity, technology, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumesAct(nn,z,as,tox,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "D1"
					);
					
					!Write the table: Flexibility Technologies(node, technology, type, period)=======================================================================================
					axll::SelectSheet("Flexibility_Technologies");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rflexibility_volumesTech(nn,tb,tox,pnz),
					  RowHeaderRange : "A2:C5000",
					  ColumnHeaderRange : "D1:ZZ1",
					  DataRange : "D2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Technology
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!Write the table: ResLoad Decomposition(node, type, period)=======================================================================================
					axll::SelectSheet("ResLoad_Decomposition");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : Rdecomposition_resLoadY(nn,torlf,pnz),
					  RowHeaderRange : "A2:B5000",
					  ColumnHeaderRange : "C1:ZZ1",
					  DataRange : "C2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "B1"
					);
					
					!Write the table: LCOPs Sector(nn,z,tots,toc,pnz)=======================================================================================
					axll::SelectSheet("LCOPs_Conversion");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOP_secE(nn,z,tots,toc,pnz),
					  RowHeaderRange : "A2:D5000",
					  ColumnHeaderRange : "E1:ZZ1",
					  DataRange : "E2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "D1"
					);
					
					!Write the table: LCOPs Activity(nn,z,as,tots,toc,pnz)=======================================================================================
					axll::SelectSheet("LCOPs_Activities");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOP_act(nn,z,as,tots,toc,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Sector
					axll:: WriteSingleValue(
						ScalarReference 	:  sector_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: LCOE(nn,as,tb,tol,pnz)=======================================================================================
					axll::SelectSheet("LCOEs");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RLCOE(nn,as,tb,tolm,tol,pnz),
					  RowHeaderRange : "A2:E5000",
					  ColumnHeaderRange : "F1:ZZ1",
					  DataRange : "F2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Node
					axll:: WriteSingleValue(
						ScalarReference 	:  node_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Tech ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "C1"
					);
					!Write the parameter: Type1
					axll:: WriteSingleValue(
						ScalarReference 	:  type1_string,
						Cell           		:  "D1"
					);
					!Write the parameter: Type2
					axll:: WriteSingleValue(
						ScalarReference 	:  type2_string,
						Cell           		:  "E1"
					);
					
					!Write the table: Internatrional Transport(type, period)=======================================================================================
					axll::SelectSheet("International_Transport");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : RintTransport_indicators(toitr,pnz),
					  RowHeaderRange : "A2:A5000",
					  ColumnHeaderRange : "B1:ZZ1",
					  DataRange : "B2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "A1"
					);
					
					!Write the table: tech_info(technology, types of info)==========================================================================================
					axll::SelectSheet("TechInfo");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : tech_info(t,tit),
					  RowHeaderRange : "A2:A5000",
					  ColumnHeaderRange : "B1:ZZ1",
					  DataRange : "B2:ZZ5000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: TECH_ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "A1"
					);
					
					!Write the table: flex_info(tff,a)=================================================================================================================
					axll::SelectSheet("FlexInfo");
					axll::ClearActiveSheet;	
					axll::WriteTable(
					  IdentifierReference : flex_info(tff,a),
					  RowHeaderRange : "A2:B1000",
					  ColumnHeaderRange : "",
					  DataRange : "C2:C1000",
					  allowRangeOverflow : 1,
					  writeZeros : 1,
					);
					!Write the parameter: TECH_ID
					axll:: WriteSingleValue(
						ScalarReference 	:  techID_string,
						Cell           		:  "A1"
					);
					!Write the parameter: Activity
					axll:: WriteSingleValue(
						ScalarReference 	:  act_string,
						Cell           		:  "B1"
					);
					!Write the parameter: Type
					axll:: WriteSingleValue(
						ScalarReference 	:  type_string,
						Cell           		:  "C1"
					);
					
					!!Write the table: act_units(as)=================================================================================================================
					!axll::SelectSheet("ActInfo");
					!axll::ClearActiveSheet;	
					!axll::WriteTable(
					!  IdentifierReference : act_info(as,tia),
					!  RowHeaderRange : "A2:A1000",
					!  ColumnHeaderRange : "B1:ZZ1",
					!  DataRange : "B2:ZZ1000",
					!  allowRangeOverflow : 1,
					!  writeZeros : 1,
					!);
					!!Write the parameter: TECH_ID
					!axll:: WriteSingleValue(
					!	ScalarReference 	:  act_string,
					!	Cell           		:  "A1"
					!);
					
					!Write the parameter: scenario_description======================================================================================================
					axll::SelectSheet("Scenario");
					axll::ClearActiveSheet;	
					axll:: WriteSingleValue(
						ScalarReference 	:  scenario_description,
						Cell           		:  "A3"
					);
					
					!Write the parameters: MathProgram details======================================================================================================
					axll::SelectSheet("MathProgram");
					axll::ClearActiveSheet;
					axll::WriteTable(
					  IdentifierReference		: MathProgramParameters,
					  RowHeaderRange 		: "A2:A1000",
					  ColumnHeaderRange 		: "B1:ZZ1",
					  DataRange 			: "B2:ZZ1000",
					  allowRangeOverflow 		: 1,
					  writeZeros 			: 1,
					);       
					
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_HourlyDispatch {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RPower_dispatch(nn,h,tb,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_LoadProfile_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RloadProfiles_H(nn,h,ah,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_FlexProfile_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RflexProfiles_H(nn,topp,h,tb,ipnz),
							RowHeaderRange : "A2:C300000",
							ColumnHeaderRange : "D1:ZZ1",
							DataRange : "D2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Type
						axll:: WriteSingleValue(
							ScalarReference 	:  type_string,
							Cell           		:  "B1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "C1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_EnergyCosts_H {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : REnergyCosts_hourly(h,ah,ipnz),
							RowHeaderRange : "A2:A10000",
							ColumnHeaderRange : "B1:ZZ1",
							DataRange : "B2:ZZ10000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "A1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_LoadProfile_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RloadProfiles_D(nn,d,ad,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_FlexProfile_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : RfinProfiles_D(nn,d,tg,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_EnergyCosts_D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : REnergyCosts_nodeD(nn,d,ad,ipnz),
							RowHeaderRange : "A2:B10000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ10000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Day
						axll:: WriteSingleValue(
							ScalarReference 	:  day_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_Profile_3D {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rprofiles3D(nn,w,h_d,t3a,ipnz),
							RowHeaderRange : "A2:C300000",
							ColumnHeaderRange : "D1:ZZ1",
							DataRange : "D2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Week
						axll:: WriteSingleValue(
							ScalarReference 	:  week_string,
							Cell           		:  "B1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "C1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_ResidualLoad {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rresidual_load(nn,h,torl,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure DataWriting_supplyResLoad {
				Arguments: (FileLocation);
				Body: {
					if axll::WorkBookIsOpen(FileLocation) then
						!Open the workbook
					        axll::SelectWorkBook(FileLocation);
					else
						!Create a new workbook
						axll::CreateNewWorkBook(
						WorkbookFilename:FileLocation,
						FirstSheetName: "temp"
						);
					endif;
					
					!--------------------------------------------------------------------------------
					
					for (ipnz in periods_nonzeros) do
						axll::CreateSheet(SheetName : ipnz);
						axll::SelectSheet(ipnz);
						axll::ClearActiveSheet;	
						axll::WriteTable(
							IdentifierReference : Rdecomposition_resLoad(nn,h,torlf,ipnz),
							RowHeaderRange : "A2:B300000",
							ColumnHeaderRange : "C1:ZZ1",
							DataRange : "C2:ZZ300000",
							allowRangeOverflow : 1,
							includeEmptyRowsColumns : 0,
							writeZeros : 1
						);
						!Write the parameter: Node
						axll:: WriteSingleValue(
							ScalarReference 	:  node_string,
							Cell           		:  "A1"
						);
						!Write the parameter: Hour
						axll:: WriteSingleValue(
							ScalarReference 	:  hour_string,
							Cell           		:  "B1"
						);
					endfor;
					
					axll::DeleteSheet(SheetName: "temp");
					
					axll::CloseWorkBook(FileLocation);
				}
				StringParameter FileLocation {
					Property: Input;
				}
			}
			Procedure runDataWritingTransition {
				Body: {
					!General data
					StatusMessage("Saving Output_General.xlsx ..." );
					DataWriting_General("Output/"+OutputFolderName+"/"+OutputFolderName+"_General.xlsx");
					
					!If hourly reports are required
					if (HourlyReportValue = 'yes') then
						StatusMessage("Saving Output_HourlyDispatch.xlsx ..." );
						DataWriting_HourlyDispatch("Output/"+OutputFolderName+"/"+OutputFolderName+"_HourlyDispatch.xlsx");
						StatusMessage("Saving Output_LoadProfile_H.xlsx ..." );
						DataWriting_LoadProfile_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_LoadProfile_H.xlsx");
						StatusMessage("Saving Output_FlexProfile_H.xlsx ..." );
						DataWriting_FlexProfile_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_FlexProfile_H.xlsx");
						StatusMessage("Saving Output_EnergyCosts_H.xlsx ..." );
						DataWriting_EnergyCosts_H("Output/"+OutputFolderName+"/"+OutputFolderName+"_EnergyCosts_H.xlsx");
						StatusMessage("Saving Output_LoadProfile_D.xlsx ..." );
						DataWriting_LoadProfile_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_LoadProfile_D.xlsx");
						StatusMessage("Saving Output_FlexProfile_D.xlsx ..." );
						DataWriting_FlexProfile_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_FlexProfile_D.xlsx");
						StatusMessage("Saving Output_EnergyCosts_D.xlsx ..." );
						DataWriting_EnergyCosts_D("Output/"+OutputFolderName+"/"+OutputFolderName+"_EnergyCosts_D.xlsx");
						StatusMessage("Saving Output_Profile_3D.xlsx ..." );
						DataWriting_Profile_3D("Output/"+OutputFolderName+"/"+OutputFolderName+"_Profile_3D.xlsx");
						StatusMessage("Saving Output_ResidualLoad.xlsx ..." );
						DataWriting_ResidualLoad("Output/"+OutputFolderName+"/"+OutputFolderName+"_ResidualLoad.xlsx");
						StatusMessage("Saving Output_supplyResLoad.xlsx ..." );
						DataWriting_supplyResLoad("Output/"+OutputFolderName+"/"+OutputFolderName+"_supplyResLoad.xlsx");
					endif;
					
					StatusMessage("Saving excel outputs Finished!" );
				}
			}
		}
		Procedure LoadCase_fromFile {
			Body: {
				!Load case as active from a data file
				CaseFileLoad(DataCaseLocation);
				
				StatusMessage("Data case was succesfully loaded" );
			}
		}
		Procedure LoadCase_ref2020 {
			Body: {
				!Load Ref2020 if requried and overwrite the input data files.
				if (Ref2020_Exist = 1) then
					!Load case as active from a data file
					CaseFileLoad('Output\\REF2020\\REF2020.data');
				endif;
			}
		}
	}
	Section Auxiliary {
		StringParameter AIMMSWavDLL {
			Definition: {
				if AimmsStringConstants('Architecture') = 'x86' then
				        "Aimmswav.dll"
				else
				        "Aimmswav64.dll"
				endif
			}
		}
		ExternalProcedure AIMMSWav {
			Arguments: (AWWavFile,AWAsync);
			DllName: "Alarm\\AimmsWav64.dll";
			ReturnType: integer;
			BodyCall: PlayWavFile( string scalar: AWWavFile, integer scalar: AWAsync );
			Comment: "This procedure will play the specified \'AWWavFile\' asynchronized (\'AWAsync\'=0) or synchronized (\'AWAsync\'=1)";
			StringParameter AWWavFile {
				Property: Input;
			}
			Parameter AWAsync {
				Range: binary;
				Default: 1;
				Property: Optional;
			}
		}
		DeclarationSection Sound_Declarations {
			StringParameter Finalized {
				Default: "Alarm\\mario_win.wav";
			}
			StringParameter Failed {
				Default: "Alarm\\mario_fail.wav";
			}
			StringParameter Signal {
				Default: "Alarm\\signal.wav";
			}
			StringParameter Signal2 {
				Default: "Alarm\\signal2.wav";
			}
		}
		Procedure AuxProcedure {
			Body: {
				!Procedure to perform calculations or modify values of parameters without reruning the whole program
				
				
				!periods_selection := {2030,2035,2040,2045,2050};
				!techStock(t,pss) := StechStock(t,pss);
				!if (IntrayearValue='min-max') then
				!	!Fix the stocks for the next runs
				!	techStock(tn,pss):=max(techStock(tn,pss)*10000,0)/10000;
				!	techStock_min(tn,pss):=techStock(tn,pss)*(1-techStock_tolerance)*(techStock(tn,pss)>1e-5);
				!	techStock_max(tn,pss):=min(techStock(tn,pss)*(1+techStock_tolerance),techStock_max(tn,pss))*(techStock(tn,pss)>1e-5);
				!elseif (IntrayearValue='Pstock') then
				!	!Fix the stocks for the next runs
				!	TechStock_roundUP;
				!	techStock(t,pss).nonvar:=1;
				!endif;
				
				!!4) Store tech_stock for a test run
				!StechStock(t,p) := techStock(t,p);
				
				!!3) Test the reporting of the flexibility profiles
				!empty RrefProfiles_flex, RfinProfiles_flex;
				!RrefProfiles_flex(h,tb,pnz) := refProfiles_flex(h,tb,pnz);
				!RfinProfiles_flex(h,tb,pnz) := finProfiles_flex(h,tb,pnz);
				
				!!2) Add Imported Natural Gas to the energy types set on 22/Sep/2020 
				!set_of_everything := set_of_everything + StringToElement(set_of_everything,"Imported Natural Gas",1);
				!energy_types := energy_types + StringToElement(energy_types,"Imported Natural Gas",1);
				
				!!1) Give value to Pyearly_prices and PCO2_prices
				!Pyearly_prices(as,p) := yearly_prices(as,p);
				!PCO2_prices(ac,p) := CO2_prices(ac,p);
				
				StatusMessage("Aux procedure finished" );
			}
		}
	}
	Procedure SolveTransition {
		Body: {
			!Delete all identifiers
			cleanup AllIdentifiers;
			
			!Declare the start time of Run for calculating Elapsed time
			ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			!Declare folder names for saving output files
			if(OutputFolderValue = 'automatic') then
				OutputFolderName := CurrentToString("%c%y-%m-%d_%H.%M");
			endif;
			
			!Assign the periods to solve
			periods_solve := periods_selection;
			
			!Assign a weight to each period
			period_weightUSE(pss) := period_weightSTAIR(pss);
			
			!First remove all the solversessions that currently might be active
			while card(IndexSolverSessions) do
				gmp::Instance::DeleteSolverSession(first(IndexSolverSessions)) ;
			endwhile ;
			
			!Now remove any of the GMPs that might still be present
			while card(IndexGeneratedMathematicalPrograms) do
				gmp::Instance::Delete(first(IndexGeneratedMathematicalPrograms)) ;
			endwhile ;
			
			!Assign a transitional value
			transition_selection := 'Simultaneous';
			
			!Assign the emission controller as 0
			negEmissions_controller := 0;
			
			! Set solver options
			DefineSolverSettings;
			
			! Define which shadow prices we want to obtain
			property balance_activities.ShadowPrice := on;
			property balance_activitiesHourly.ShadowPrice := on;
			property balance_activitiesDaily.ShadowPrice := on;
			
			!Solve the GMP
			!============================================================= Start of the Solve procedure =============================================================
			! Set the running state initial value
			run_numberState:=1;
			
			! Report database location and reset math program parameters reporting
			empty MathProgramParameters;
			MathProgramParameters('Database Version',1) := DataReadingLocation ;
			
			! Creating stopwatch for the generation time
			ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			StatusMessage("ST... Generating the transition GMP for periods: " + periods_solve);
			! Create a solver session for GenMathProgram, which will create an element in the set AllSolverSessions, and assign the newly created element to the element parameter session.
			GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
			for IndexGeneratedMathematicalPrograms do
				MemoryUseMPs(IndexGeneratedMathematicalPrograms) := GMP::Instance::GetMemoryUsed(IndexGeneratedMathematicalPrograms);
				endfor;
			
			if not GMP_planning then raise warning "Could not generate the GMP!"; AIMMSWav(Failed); return; endif;
			
			MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),1);
			
			!StatusMessage("ST... Presolving the transition GMP for periods: " + periods_solve );
			! Create a linear presolved GMP
			!presGMP_planning := GMP::Instance::CreatePresolved(GMP_planning,"Transition"+periods_solve);
			!if not presGMP_planning then raise warning "Could not presolve the GMP!"; endif;
			
			!Set solver
			!GMP::Instance::SetSolver(presGMP_planning,SolverChoiceTransition);
			GMP::Instance::SetSolver(GMP_planning,SolverChoiceTransition);
			
			StatusMessage("ST... Solving the transition GMP for periods: " + periods_solve );
			! Solve the presolved GMP
			!GMP::Instance::Solve(presGMP_planning ) ;
			
			! Solve the GMP
			GMP::Instance::Solve(GMP_planning ) ;
			
			! Get Progress window parameters for reporting purposes
			!GMP_details(run_numberState,presGMP_planning,ReferenceTime);
			GMP_details(run_numberState,GMP_planning,ReferenceTime);
			
			StatusMessage("ST... Solving the transition GMP is Finished!");
			!============================================================= End of the Solve procedure =============================================================
			
			run_numberState:=run_numberState+1;
			
			!Save the variable values
			Ptech_use(tb,pss):=tech_use(tb,pss);
			Ptech_useHourly(h,th,pss):=tech_useHourly(h,th,pss);
			Ptech_useDaily(d,td,pss):=tech_useDaily(d,td,pss);
			PdeltaQ_UP(h,tf,pss):=deltaQ_UP(h,tf,pss);
			PdeltaQ_DW(h,tf,pss):=deltaQ_DW(h,tf,pss);
			PdeltaQ_S(h,tfb,pss):=deltaQ_S(h,tfb,pss);
			PdeltaQd_UP(d,tfl,pss):=deltaQd_UP(d,tfl,pss);
			PdeltaQd_DW(d,tfl,pss):=deltaQd_DW(d,tfl,pss);
			PdeltaU_CHP(h,tk,pss):=deltaU_CHP(h,tk,pss);
			PdeltaB_UP(d,tg,pss):=deltaB_UP(d,tg,pss);
			PdeltaB_DW(d,tg,pss):=deltaB_DW(d,tg,pss);
			PdeltaB_S(d,tg,pss):=deltaB_S(d,tg,pss);
			PdeltaP_CHP(h,tk,pss):=deltaP_CHP(h,tk,pss);
			PdeltaS_shed(h,ts,pss):=deltaS_shed(h,ts,pss);
			Pcap_investments(t,pss):=cap_investments(t,pss);
			Pretrofitting(it,jt,pss):=retrofitting(it,jt,pss);
			Peco_decommisioning(t,pss):=eco_decommisioning(t,pss);
			PdecomStock(t,pss):=decomStock(t,pss);
			PtechStock(t,pss):=techStock(t,pss);
			StechStock(t,pss):=techStock(t,pss);
			Ptotal_costs:=totalCosts_planning;
			
			!if GMP::Solution::GetProgramStatus(presGMP_planning,1) = 'Optimal' then
			if GMP::Solution::GetProgramStatus(GMP_planning,1) = 'Optimal' then
				!Extract the prices
				!First extract the shadow prices for all the periods, then divide for the years of solution (where the weight is different than zero)
				!corrected by Kira to multiply by social discount factor instead of divide
				yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
				yearly_prices(as,pss):=yearly_prices(as,pss)*social_discount_factor(pss);
				CO2_prices(ac,pss):= yearly_prices(ac,pss);
				Pyearly_prices(as,pss) := yearly_prices(as,pss); 
				PCO2_prices(ac,pss) := CO2_prices(ac,pss);
				CO2_price_single(n,p) := emission_target(n,p).ShadowPrice;
				CO2_price_single(n,pss) := CO2_price_single(n,pss)*social_discount_factor(pss);
				!Save intrayear prices (shadow prices)
				hourly_prices(h,ah,p):=balance_activitiesHourly(h,ah,p).ShadowPrice;
				hourly_prices(h,ah,pss):=hourly_prices(h,ah,pss)*social_discount_factor(pss);
				daily_prices(d,ad,p):=balance_activitiesDaily(d,ad,p).ShadowPrice;
				daily_prices(d,ad,pss):=daily_prices(d,ad,pss)*social_discount_factor(pss);
			
				!Assign the emission controller as 1
				negEmissions_controller := 1;
			
				! Write model version
				MathProgramParameters('Model Version',1) := project_name;
			
				! Create a directory for Output files
				if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
			
				!Save the data file
				StatusMessage("Copying the input datafile ..." );
				FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
			
				!Save the case file
				StatusMessage("Saving the temp Case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
			
				!Round the post processing routines before saving and writing the data.
				EmissionAdjustment;
				EnergyCosts_calculator;
				PostProcessParameters;
				RoundParameters;
			
				!Save the case file
				StatusMessage("Saving the Case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
				FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
			
				! Calculate the elapsed time for reporting purposes
				MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
				!Write the output of the model
				StatusMessage("ST... Writing the Outputs ..." );
				runDataWritingTransition;
			
				!Play the alarm
				AIMMSWav(Finalized);
			
				StatusMessage("Solve transition is successfully finished!" );
			
			!elseif GMP::Solution::GetProgramStatus(presGMP_planning,1) = 'Intermediate non-optimal' then
			elseif GMP::Solution::GetProgramStatus(GMP_planning,1) = 'Intermediate non-optimal' then
				!Extract the prices
				!First extract the shadow prices for all the periods, then divide for the years of solution (where the weight is different than zero)
				yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
				yearly_prices(as,pss):=yearly_prices(as,pss)*social_discount_factor(pss);
				CO2_prices(ac,pss):= yearly_prices(ac,pss);
				Pyearly_prices(as,pss) := yearly_prices(as,pss); 
				PCO2_prices(ac,pss) := CO2_prices(ac,pss);
				CO2_price_single(n,p) := emission_target(n,p).ShadowPrice;
				CO2_price_single(n,pss) := CO2_price_single(n,pss)*social_discount_factor(pss);
				!Save intrayear prices
				hourly_prices(h,ah,p):=balance_activitiesHourly(h,ah,p).ShadowPrice;
				hourly_prices(h,ah,pss):=hourly_prices(h,ah,pss)*social_discount_factor(pss);
				daily_prices(d,ad,p):=balance_activitiesDaily(d,ad,p).ShadowPrice;
				daily_prices(d,ad,pss):=daily_prices(d,ad,pss)*social_discount_factor(pss);
			
				!Assign the emission controller as 1
				negEmissions_controller := 1;
			
				! Write model version
				MathProgramParameters('Model Version',1) := project_name;
			
				! Creat a directory for Output files
				if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
			
				!Save the data file
				StatusMessage("Copying the input datafile ..." );
				FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
			
				!Save the case file
				StatusMessage("Saving the temp Case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
			
				!Round the post processing routines before saving and writing the data.
				EmissionAdjustment;
				EnergyCosts_calculator;
				PostProcessParameters;
				RoundParameters;
			
				!Save the case file
				StatusMessage("Saving the Case as a datafile ..." );
				CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
				FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
			
				! Calculate the elapsed time for reporting purposes
				MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
				!Write the output of the model
				StatusMessage("ST... Writing the Outputs ..." );
				runDataWritingTransition;
			
				!Play the alarm
				AIMMSWav(Signal);
			
				StatusMessage("!!! Intermediate non-optimal !!!" );
			else
				! Calculate the elapsed time for reporting purposes
				MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
				!Play the alarm
				AIMMSWav(Failed);
				StatusMessage("Error or no solution" );
			endif;
		}
	}
	Procedure SolveTransition_IYP {
		Body: {
			!Delete all identifiers
			cleanup AllIdentifiers;
			
			!Declare the start time of Run for calculating Elapsed time
			ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			!Declare folder names for saving output files
			if(OutputFolderValue = 'automatic') then
				OutputFolderName := CurrentToString("%c%y-%m-%d_%H.%M");
			endif;
			
			!Assign the periods to solve
			periods_solve := periods_selection;
			
			!Assign a weight to each period
			period_weightUSE(pss) := period_weightSTAIR(pss);
			
			!First remove all the solversessions that currently might be active
			while card(IndexSolverSessions) do
				gmp::Instance::DeleteSolverSession(first(IndexSolverSessions)) ;
			endwhile ;
			
			!Now remove any of the GMPs that might still be present
			while card(IndexGeneratedMathematicalPrograms) do
				gmp::Instance::Delete(first(IndexGeneratedMathematicalPrograms)) ;
			endwhile ;
			
			!Assign a transitional value
			transition_selection := 'Simultaneous';
			
			!Assign the emission controller as 0
			negEmissions_controller := 0;
			
			! Set solver options
			DefineSolverSettings;
			
			! Define which shadow prices we want to obtain
			property balance_activities.ShadowPrice := on;
			property balance_activitiesHourly.ShadowPrice := on;
			property balance_activitiesDaily.ShadowPrice := on;
			
			!Solve the GMP
			!============================================================= Start of the Solve procedure =============================================================
			! Set the running state initial value
			run_numberState:=1;
			
			! Report database location and reset math program parameters reporting
			empty MathProgramParameters;
			MathProgramParameters('Database Version',1) := DataReadingLocation ;
			
			! Creating stopwatch for the generation time
			ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			StatusMessage("T+IYP... Generating the transition GMP for periods: " + periods_solve);
			! Create a solver session for GenMathProgram, which will create an element in the set AllSolverSessions, and assign the newly created element to the element parameter session.
			GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
			for IndexGeneratedMathematicalPrograms do
				MemoryUseMPs(IndexGeneratedMathematicalPrograms) := GMP::Instance::GetMemoryUsed(IndexGeneratedMathematicalPrograms);
				endfor;
			
			if not GMP_planning then raise warning "Could not generate the GMP!"; AIMMSWav(Failed); return; endif;
			
			MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),1);
			
			!StatusMessage("T+IYP... Presolving the transition GMP for periods: " + periods_solve );
			! Create a linear presolved GMP
			!presGMP_planning := GMP::Instance::CreatePresolved(GMP_planning,"Transition"+SetAsString(periods_solve));
			!if not presGMP_planning then raise warning "Could not presolve the GMP!"; endif;
			
			!Set solver
			!GMP::Instance::SetSolver(presGMP_planning,SolverChoiceTransition);
			GMP::Instance::SetSolver(GMP_planning,SolverChoiceTransition);
			
			StatusMessage("T+IYP... Solving the transition GMP for periods: " + periods_solve );
			! Solve the presolved GMP
			!GMP::Instance::Solve(presGMP_planning ) ;
			
			! Solve the GMP
			GMP::Instance::Solve(GMP_planning ) ;
			
			! Get Progress window parameters for reporting purposes
			!GMP_details(run_numberState,presGMP_planning,ReferenceTime);
			GMP_details(run_numberState,GMP_planning,ReferenceTime);
			
			StatusMessage("ST... Solving the transition GMP is Finished!");
			!============================================================= End of the Solve procedure =============================================================
			
			run_numberState:=run_numberState+1;
			
			!Save the variable values
			Ptech_use(tb,pss):=tech_use(tb,pss);
			Ptech_useHourly(h,th,pss):=tech_useHourly(h,th,pss);
			Ptech_useDaily(d,td,pss):=tech_useDaily(d,td,pss);
			PdeltaQ_UP(h,tf,pss):=deltaQ_UP(h,tf,pss);
			PdeltaQ_DW(h,tf,pss):=deltaQ_DW(h,tf,pss);
			PdeltaQ_S(h,tfb,pss):=deltaQ_S(h,tfb,pss);
			PdeltaQd_UP(d,tfl,pss):=deltaQd_UP(d,tfl,pss);
			PdeltaQd_DW(d,tfl,pss):=deltaQd_DW(d,tfl,pss);
			PdeltaU_CHP(h,tk,pss):=deltaU_CHP(h,tk,pss);
			PdeltaB_UP(d,tg,pss):=deltaB_UP(d,tg,pss);
			PdeltaB_DW(d,tg,pss):=deltaB_DW(d,tg,pss);
			PdeltaB_S(d,tg,pss):=deltaB_S(d,tg,pss);
			PdeltaP_CHP(h,tk,pss):=deltaP_CHP(h,tk,pss);
			PdeltaS_shed(h,ts,pss):=deltaS_shed(h,ts,pss);
			Pcap_investments(t,pss):=cap_investments(t,pss);
			Pretrofitting(it,jt,pss):=retrofitting(it,jt,pss);
			Peco_decommisioning(t,pss):=eco_decommisioning(t,pss);
			PdecomStock(t,pss):=decomStock(t,pss);
			PtechStock(t,pss):=techStock(t,pss);
			StechStock(t,pss):=techStock(t,pss);
			Ptotal_costs:=totalCosts_planning;
			
			!if GMP::Solution::GetProgramStatus(presGMP_planning,1) = 'Optimal' then
			if GMP::Solution::GetProgramStatus(GMP_planning,1) = 'Optimal' then
				!Extract the prices
				!First extract the shadow prices for all the periods, then divide for the years of solution (where the weight is different than zero)
				!corrected by Kira to multiply instead of divide
				yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
				yearly_prices(as,pss):=yearly_prices(as,pss)*social_discount_factor(pss);
				CO2_prices(ac,pss):= yearly_prices(ac,pss);
				Pyearly_prices(as,pss) := yearly_prices(as,pss); 
				PCO2_prices(ac,pss) := CO2_prices(ac,pss);
				CO2_price_single(n,p) := emission_target(n,p).ShadowPrice;
				CO2_price_single(n,pss) := CO2_price_single(n,pss)*social_discount_factor(pss);
			
				!Assign the emission controller as 1
				negEmissions_controller := 1;
			
				! Write model version
				MathProgramParameters('Model Version',1) := project_name;
			
				!Play the alarm
				AIMMSWav(Signal2);
				StatusMessage("Solve transition is finished! Starting IYP!" );
			else
				! Calculate the elapsed time for reporting purposes
				MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
				!Play the alarm
				AIMMSWav(Failed);
				StatusMessage("Error! IYP won't start!" );
				RETURN 1;
			endif;
			
			!======================================================================== Start IYP phase =============================================================
			
			! Declare folder names for saving output files
			if(OutputFolderValue = 'automatic') then
				OutputFolderName := CurrentToString("%c%y-%m-%d_%H.%M");
			endif;
			
			!Prepare the run(s)
			run_numberState:=2;
			
			!Apply the desired intra-year method
			IntrayearValue := 'Pstock';
			techStock(t,pss) := round(StechStock(t,pss),8);
			if (IntrayearValue='min-max') then
				!Fix the stocks for the next runs
				techStock(t,pss):=max(techStock(t,pss)*10000,0)/10000;
				techStock_min(t,pss):=techStock(t,pss)*(1-techStock_tolerance)*(techStock(t,pss)>1e-5);
				techStock_max(t,pss):=min(techStock(t,pss)*(1+techStock_tolerance),techStock_max(t,pss))*(techStock(t,pss)>1e-5);
			elseif (IntrayearValue='Pstock') then
				!Fix the stocks for the next runs
				TechStock_roundUP;
				techStock(t,pss).nonvar:=1;
			endif;
			
			! Set solver options for crossover phase
			option scale_model:= 'On';
			
			! Define which shadow prices we want to obtain
			property balance_activities.ShadowPrice := off;
			property balance_activitiesDaily.ShadowPrice := on;
			property balance_activitiesHourly.ShadowPrice := on;
			
			!Redefine weight of the year to 1
			!period_weightUSE(pss):=1;
			social_discount_rate:=0;
			
			!First remove all the solversessions that currently might be active
			while card(IndexSolverSessions) do
				gmp::Instance::DeleteSolverSession(first(IndexSolverSessions)) ;
			endwhile ;
			
			!Now remove any of the GMPs that might still be present
			while card(IndexGeneratedMathematicalPrograms) do
				gmp::Instance::Delete(first(IndexGeneratedMathematicalPrograms)) ;
			endwhile ;
			
			! Declare the start time of crossover for calculating Elapsed time
			ReferenceTime_IYP := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			!Sort the periods selection set to start with the latest period
			!periods_selection := sort(ipss in periods_selection,-ipss); 
			
			for (ipss in periods_selection) do
			
				!Assign a specific number of threads to each solver session
				option 'GUROBI 10.0'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'GUROBI 9.5'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'GUROBI 9.1'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'GUROBI 9.0'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'GUROBI 8.1'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'CPLEX 12.1'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'CPLEX 20.1'.Thread_limit := Floor(NumCPU/card(periods_selection));
				option 'CPLEX 22.1'.Thread_limit := Floor(NumCPU/card(periods_selection));
			
				periods_solve:=ipss;
			
				! Creating stopwatch for the generation time
				ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
				StatusMessage("T+IYP... Generating GMP for period: " + ipss + " of " + periods_selection);
			
				!Apply the desired intra-year method to generate the GMP
				if (IntrayearValue='Pstock') then
					!Solve LeastCostOperation
					AY_GMP(ipss) := GMP::Instance::Generate(LeastCostOperation, "GMP_" + ipss);
					if not AY_GMP(ipss) then raise warning "Could not generate the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				elseif (IntrayearValue='min-max') then
					!Solve LeastCostPlanning
					AY_GMP(ipss) := GMP::Instance::Generate(LeastCostPlanning, "GMP_" + ipss);
					if not AY_GMP(ipss) then raise warning "Could not generate the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				endif;
			
				!StatusMessage("T+IYP... Presolving GMP for period: " + ipss + " of " + periods_selection);
				!pres_AY_GMP(ipss) := GMP::Instance::CreatePresolved(AY_GMP(ipss), "pres_GMP_" + ipss);
				!if not pres_AY_GMP(ipss) then raise warning "Could not presolve the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				!GMP::Instance::SetSolver(pres_AY_GMP(ipss),SolverChoiceIYP);
			
				MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),2);
			
			!	if pres_AY_GMP(ipss) then
			!		AY_SolverSession(ipss) := GMP::Instance::CreateSolverSession(pres_AY_GMP(ipss),"SS_" + ipss);
			!		ProgressWindow := GMP::SolverSession::CreateProgressCategory(AY_SolverSession(ipss));
			!		GMP::Solution::RetrieveFromModel(pres_AY_GMP(ipss),1);
			!		MathProgramParameters('Number of Constraints',run_numberState) := GMP::Instance::GetNumberOfRows(pres_AY_GMP(ipss));
			!		MathProgramParameters('Number of Variables',run_numberState) := GMP::Instance::GetNumberOfColumns(pres_AY_GMP(ipss));
			!		MathProgramParameters('Number of Nonzeros',run_numberState) := GMP::Instance::GetNumberOfNonzeros(pres_AY_GMP(ipss));
			!	elseif AY_GMP(ipss) then
			!		raise warning " ===== Presolving of period " + ipss +" failed. Solving the original GMP instead.";
					AY_SolverSession(ipss) := GMP::Instance::CreateSolverSession(AY_GMP(ipss),"SS_" + ipss);
					ProgressWindow := GMP::SolverSession::CreateProgressCategory(AY_SolverSession(ipss));
					GMP::Solution::RetrieveFromModel(AY_GMP(ipss),1);
					MathProgramParameters('Number of Constraints',run_numberState) := GMP::Instance::GetNumberOfRows(AY_GMP(ipss));
					MathProgramParameters('Number of Variables',run_numberState) := GMP::Instance::GetNumberOfColumns(AY_GMP(ipss));
					MathProgramParameters('Number of Nonzeros',run_numberState) := GMP::Instance::GetNumberOfNonzeros(AY_GMP(ipss));
			!	endif;
			
				GMP::Solution::SendToSolverSession(AY_SolverSession(ipss),1);
				StatusMessage("T+IYP... AsynchronousExecute period: " + ipss + " of " + periods_selection);
				GMP::SolverSession::AsynchronousExecute(AY_SolverSession(ipss));
			
				run_numberState:= run_numberState + 1;
			
				!Play the alarm
				AIMMSWav(Signal);
			
			endfor;
			
			run_numberState:= 2;
			
			while card(AllsolverSessions) do
			 	FinishedSS := GMP::SolverSession::WaitForSingleCompletion(solSesSet : AllSolverSessions);
			 	for (ipss in periods_selection) do
			 		if StringOccurrences(FinishedSS,ipss)>0 then
			 			StatusMessage("T+IYP... Retrieveing solution for period " + ipss);
			 			periods_solve:=ipss;
						GMP::Solution::RetrieveFromSolverSession(AY_SolverSession(ipss), 1);
						if pres_AY_GMP(ipss) then
							if (GMP::Solution::GetProgramStatus(pres_AY_GMP(ipss),1) <> 'Optimal') then
								raise warning " ===== Could not find Optimal solution for GMP of period " + ipss +" of " + SetAsString(periods_selection);
								! Get Progress window parameters for reporting purposes
								GMP_details(run_numberState,pres_AY_GMP(ipss),ReferenceTime_IYP);
								periods_selection := periods_selection - ipss;
								run_numberState:=run_numberState+1;
								AIMMSWav(Failed);
								return;
							endif;
							GMP::Solution::SendToModel(pres_AY_GMP(ipss), 1);
							! Get Progress window parameters for reporting purposes
							GMP_details(run_numberState,pres_AY_GMP(ipss),ReferenceTime_IYP);
							run_numberState:=run_numberState+1;
						elseif AY_GMP(ipss) then
							if (GMP::Solution::GetProgramStatus(AY_GMP(ipss),1) <> 'Optimal') then
								raise warning " ===== Could not find Optimal solution for GMP of period " + ipss +" of " + SetAsString(periods_selection);
								! Get Progress window parameters for reporting purposes
								GMP_details(run_numberState,AY_GMP(ipss),ReferenceTime_IYP);
								periods_selection := periods_selection - ipss;
								run_numberState:=run_numberState+1;
								AIMMSWav(Failed);
								return;
							endif;
							GMP::Solution::SendToModel(AY_GMP(ipss), 1);
							! Get Progress window parameters for reporting purposes
							GMP_details(run_numberState,AY_GMP(ipss),ReferenceTime_IYP);
							run_numberState:=run_numberState+1;
						endif;
			
						!Write the outcomes of each year solution
						Ptech_use(t,ipss):=tech_use(t,ipss);
						Ptech_useHourly(h,th,ipss):=tech_useHourly(h,th,ipss);
						Ptech_useDaily(d,td,ipss):=tech_useDaily(d,td,ipss);
						PdeltaQ_UP(h,tf,ipss):=deltaQ_UP(h,tf,ipss);
						PdeltaQ_DW(h,tf,ipss):=deltaQ_DW(h,tf,ipss);
						PdeltaQ_S(h,tfb,ipss):=deltaQ_S(h,tfb,ipss);
						PdeltaQd_UP(d,tfl,ipss):=deltaQd_UP(d,tfl,ipss);
						PdeltaQd_DW(d,tfl,ipss):=deltaQd_DW(d,tfl,ipss);
						PdeltaU_CHP(h,tk,ipss):=deltaU_CHP(h,tk,ipss);
						PdeltaB_UP(d,tg,ipss):=deltaB_UP(d,tg,ipss);
						PdeltaB_DW(d,tg,ipss):=deltaB_DW(d,tg,ipss);
						PdeltaB_S(d,tg,ipss):=deltaB_S(d,tg,ipss);
						PdeltaP_CHP(h,tk,ipss):=deltaP_CHP(h,tk,ipss);
						PdeltaS_shed(h,ts,ipss):=deltaS_shed(h,ts,ipss);
						Ptotal_costs:=Ptotal_costs+totalCosts_planning*period_weightSTAIR(ipss); !Change this one accordingly with SIMULTANEOUS to ensure a good comparisson
						!Save intrayear prices
						hourly_prices(h,ah,ipss):=balance_activitiesHourly(h,ah,ipss).ShadowPrice;
						daily_prices(d,ad,ipss):=balance_activitiesDaily(d,ad,ipss).ShadowPrice;
			
			    			GMP::Instance::DeleteSolverSession(FinishedSS) ;
			    			if pres_AY_GMP(ipss) then GMP::Instance::Delete(pres_AY_GMP(ipss)); endif;
			    			if AY_GMP(ipss) then GMP::Instance::Delete(AY_GMP(ipss)); endif;
			    			periods_selection := periods_selection - ipss;
			 		endif;
			 		StatusMessage("T+IYP... Periods " + periods_selection + "  are not solved yet!");
			 	endfor;
			    	if card(periods_selection) = 0 then BREAK; endif;
			endwhile ;
			
			
			! Write model version
			MathProgramParameters('Model Version',1) := project_name;
			
			! Create a directory for Output files
			if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
			
			!Save the data file
			StatusMessage("Copying the input datafile ..." );
			FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
			
			!Save the temp case file
			StatusMessage("Saving the temp Case as a datafile ..." );
			CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
			
			!Round the post processing routines before saving and writing the data.
			EmissionAdjustment;
			EnergyCosts_calculator;
			PostProcessParameters;
			RoundParameters;
			
			!Save the case file
			StatusMessage("Saving the Case as a datafile ..." );
			CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
			FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
			
			! Calculate the elapsed time for reporting purposes
			MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
			!Write the output of the model
			StatusMessage("T+IYP... Writing the excel outputs ..." );
			runDataWritingTransition;
			
			!!First remove all the solversessions that currently might be active
			!while card(IndexSolverSessions) do
			!	gmp::Instance::DeleteSolverSession( first(IndexSolverSessions) ) ;
			!endwhile ;
			!
			!!Now remove any of the GMPs that might still be present
			!while card(IndexGeneratedMathematicalPrograms) do
			!	gmp::Instance::Delete( first(IndexGeneratedMathematicalPrograms) ) ;
			!endwhile ;
			
			!Play the alarm
			AIMMSWav(Finalized);
			
			StatusMessage("Intra-year pricing is finished!" );
		}
	}
	Procedure BatchSolve {
		Body: {
			
			BS_counter := 0;
			for (ifs in InputFIlesSelection) do
				BS_counter := BS_counter + 1;
			
				DialogProgress("Batch Solving: " + ifs + ' | ' + BS_counter + " out of " + BS_length,Floor(100*BS_counter/BS_length));
			
				!Delete all identifyiers
				cleanup AllIdentifiers;
			
				DataReadingLocation := ifs;
				runDataReading;
			
				!Declare the start time of Run for calculating Elapsed time
				ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
				!Declare folder names for saving output files
				if (OutputFolderValue = 'automatic') then
					OutputFolderName := FindReplaceStrings(ifs,"data\\","") - ".xlsx" ;
				elseif (OutputFolderValue = 'custom') then
					OutputFolderName := OutputFolderPrefix + "_"  + FindReplaceStrings(ifs,"data\\","") - ".xlsx" ;
				endif;
			
				!Assign the periods to solve
				periods_solve := periods_selection;
			
				!Assign a weight to each period
				period_weightUSE(pss) := period_weightSTAIR(pss);
			
				!Assign a transitional value
				transition_selection := 'Simultaneous';
			
				!Assign the emission controller as 0
				negEmissions_controller := 0;
			
				! Set solver options
				DefineSolverSettings;
			
				! Define which shadow prices we want to obtain
				property balance_activities.ShadowPrice := on;
				property balance_activitiesHourly.ShadowPrice := on;
				property balance_activitiesDaily.ShadowPrice := on;
			
				!Solve the GMP
				!============================================================= Start of the Solve procedure =============================================================
				! Set the running state initial value
				run_numberState:=1;
			
				! Report database location and reset math program parameters reporting
				empty MathProgramParameters;
				MathProgramParameters('Database Version',1) := FindReplaceStrings(DataReadingLocation,"data\\","") ;
			
				! Creating stopwatch for the generation time
				ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
				StatusMessage(BS_counter + "/" + BS_length + "  | Generating the transition GMP for periods: " + periods_solve + ' | ' + ifs);
				! Create a solver session for GenMathProgram, which will create an element in the set AllSolverSessions, and assign the newly created element to the element parameter session.
				GMP_planning := GMP::Instance::Generate(LeastCostPlanning);
				if not GMP_planning then raise warning "Could not generate the GMP " + FindReplaceStrings(ifs,"data\\",""); AIMMSWav(Failed); SKIP; endif;
			
				MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),1);
			
				StatusMessage(BS_counter + "/" + BS_length + " Presolving the transition GMP for periods: " + periods_solve + ' | ' + ifs);
				! Create a linear presolved GMP
				presGMP_planning := GMP::Instance::CreatePresolved(GMP_planning,BS_counter+"/"+BS_length+"_BatchSolve"+SetAsString(periods_solve));
				if not presGMP_planning then raise warning "Could not presolve the GMP " + FindReplaceStrings(ifs,"data\\",""); endif;
			
				!Set solver
				GMP::Instance::SetSolver(presGMP_planning,SolverChoiceTransition);
			
				StatusMessage(BS_counter + "/" + BS_length + " Solving the transition GMP for periods: " + periods_solve + ' | ' + ifs);
				! Solve the presolved GMP
				GMP::Instance::Solve(presGMP_planning ) ;
			
				! Get Progress window parameters for reporting purposes
				GMP_details(run_numberState,presGMP_planning,ReferenceTime);
			
				StatusMessage(BS_counter + "/" + BS_length + " Solving the transition GMP is Finished!" + ' | ' + ifs);
				!============================================================= End of the Solve procedure =============================================================
			
				run_numberState:=run_numberState+1;
			
				!Save the variable values
				Ptech_use(tb,pss):=tech_use(tb,pss);
				Ptech_useHourly(h,th,pss):=tech_useHourly(h,th,pss);
				Ptech_useDaily(d,td,pss):=tech_useDaily(d,td,pss);
				PdeltaQ_UP(h,tf,pss):=deltaQ_UP(h,tf,pss);
				PdeltaQ_DW(h,tf,pss):=deltaQ_DW(h,tf,pss);
				PdeltaQ_S(h,tfb,pss):=deltaQ_S(h,tfb,pss);
				PdeltaQd_UP(d,tfl,pss):=deltaQd_UP(d,tfl,pss);
				PdeltaQd_DW(d,tfl,pss):=deltaQd_DW(d,tfl,pss);
				PdeltaU_CHP(h,tk,pss):=deltaU_CHP(h,tk,pss);
				PdeltaB_UP(d,tg,pss):=deltaB_UP(d,tg,pss);
				PdeltaB_DW(d,tg,pss):=deltaB_DW(d,tg,pss);
				PdeltaB_S(d,tg,pss):=deltaB_S(d,tg,pss);
				PdeltaP_CHP(h,tk,pss):=deltaP_CHP(h,tk,pss);
				PdeltaS_shed(h,ts,pss):=deltaS_shed(h,ts,pss);
				Pcap_investments(t,pss):=cap_investments(t,pss);
				Pretrofitting(it,jt,pss):=retrofitting(it,jt,pss);
				Peco_decommisioning(t,pss):=eco_decommisioning(t,pss);
				PdecomStock(t,pss):=decomStock(t,pss);
				PtechStock(t,pss):=techStock(t,pss);
				StechStock(t,pss):=techStock(t,pss);
				Ptotal_costs:=totalCosts_planning;
			
				if GMP::Solution::GetProgramStatus(presGMP_planning,1) = 'Optimal' then
					!Extract the prices
					!First extract the shadow prices for all the periods, then divide for the years of solution (where the weight is different than zero)
					!corrected by Kira to multiply instead of divide
					yearly_prices(as,p):=balance_activities(as,p).ShadowPrice;
					yearly_prices(as,pss):=yearly_prices(as,pss)*social_discount_factor(pss);
					CO2_prices(ac,pss):= yearly_prices(ac,pss);
					Pyearly_prices(as,pss) := yearly_prices(as,pss); 
					PCO2_prices(ac,pss) := CO2_prices(ac,pss);
					CO2_price_single(n,p) := emission_target(n,p).ShadowPrice;
					CO2_price_single(n,pss) := CO2_price_single(n,pss)*social_discount_factor(pss);
					!Save intrayear prices
					hourly_prices(h,ah,p):=balance_activitiesHourly(h,ah,p).ShadowPrice;
					hourly_prices(h,ah,pss):=hourly_prices(h,ah,pss)*social_discount_factor(pss);
					daily_prices(d,ad,p):=balance_activitiesDaily(d,ad,p).ShadowPrice;
					daily_prices(d,ad,pss):=daily_prices(d,ad,pss)*social_discount_factor(pss);
			
					!Assign the emission controller as 1
					negEmissions_controller := 1;
			
					! Write model version
					MathProgramParameters('Model Version',1) := project_name;
			
					! Creat a directory for Output files
					if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
			
					!Save the data file
					StatusMessage("Copying the input datafile ..." );
					FileCopy(DataReadingLocation,"Output/"+OutputFolderName+"/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
			
					!Save the temporary case file
					if (SaveCaseValue = 'yes') then
						StatusMessage(BS_counter + "/" + BS_length + " Saving the temp Case as a datafile ..." );
						CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
					endif;
			
					!Round the post processing routines before saving and writing the data.
					EmissionAdjustment;
					EnergyCosts_calculator;
					PostProcessParameters;
					RoundParameters;
			
					!Save the case file
					if (SaveCaseValue = 'yes') then
						StatusMessage(BS_counter + "/" + BS_length + "Saving the Case as a datafile ..." );
						CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
						FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
					endif;
			
					! Calculate the elapsed time for reporting purposes
					MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
					!Write the output of the model
					StatusMessage(BS_counter + "/" + BS_length + " Writing the Outputs ..."  + ' | ' + ifs);
					runDataWritingTransition;
			
					!Play the alarm
					AIMMSWav(Signal);
			
					StatusMessage(ifs + " is finished. " + " It took" + round(CurrentToMoment([minute],ReferenceTime),2) + " minutes");
				else
					! Calculate the elapsed time for reporting purposes
					MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
					StatusMessage("Error or no solution for " + BS_counter + " problem" );
				endif;
			
			endfor;
			
			!Play the alarm
			AIMMSWav(Finalized);
			
			StatusMessage("Batch Solve is finished.");
		}
	}
	Procedure IntraYearPrices {
		Body: {
			!Determine whether or not to apply initialization measures depending if is a direct run or is comming from transition
			DefineSolverSettings;
			
			! Declare the start time of Run for calculating Elapsed time
			ReferenceTime := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			! Declare folder names for saving output files
			!Declare folder names for saving output files
			if (OutputFolderValue = 'automatic') then
				OutputFolderName := OutputFolderName + "_P" ;
			endif;
			
			!Define the years to solve
			periods_selection := periods_window;
			
			!Prepare the run(s)
			run_numberState:=2;
			
			! Report database location
			MathProgramParameters('Database Version',1) := DataReadingLocation ;
			
			!======================================================================== Start IYP phase =============================================================
			!Apply the desired intra-year method
			IntrayearValue := 'Pstock';
			techStock(t,pss) := round(StechStock(t,pss),9);
			if (IntrayearValue='min-max') then
				!Fix the stocks for the next runs
				techStock(t,pss):=max(techStock(t,pss)*10000,0)/10000;
				techStock_min(t,pss):=techStock(t,pss)*(1-techStock_tolerance)*(techStock(t,pss)>1e-5);
				techStock_max(t,pss):=min(techStock(t,pss)*(1+techStock_tolerance),techStock_max(t,pss))*(techStock(t,pss)>1e-5);
			elseif (IntrayearValue='Pstock') then
				!Fix the stocks for the next runs
				TechStock_roundUP;
				techStock(t,pss).nonvar:=1;
			endif;
			
			! Set solver options for crossover phase
			option scale_model:= 'On';
			!Feasibility_tolerance := 1e-6;
			!Optimality_tolerance := 1e-6;
			!BarrierConvergence_tolerance := 1e-8;
			
			! Define which shadow prices we want to obtain
			property balance_activities.ShadowPrice := off;
			property balance_activitiesDaily.ShadowPrice := on;
			property balance_activitiesHourly.ShadowPrice := on;
			
			!Redefine weight of the year to 1
			period_weightUSE(pss):=1;
			
			!First remove all the solversessions that currently might be active
			while card(IndexSolverSessions) do
				gmp::Instance::DeleteSolverSession(first(IndexSolverSessions)) ;
			endwhile ;
			
			!Now remove any of the GMPs that might still be present
			while card(IndexGeneratedMathematicalPrograms) do
				gmp::Instance::Delete(first(IndexGeneratedMathematicalPrograms)) ;
			endwhile ;
			
			! Declare the start time of crossover for calculating Elapsed time
			ReferenceTime_IYP := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
			!Sort the periods selection set to start with the latest period
			!periods_selection := sort(ipss in periods_selection,-ipss); 
			
			for (ipss in periods_selection) do
			
				!Assign a specific number of threads to each solver session
				option 'GUROBI 9.1'.Thread_limit := Floor(CPUCores/card(periods_selection));
				option 'CPLEX 20.1'.Thread_limit := Floor(CPUCores/card(periods_selection));
			
				periods_solve:=ipss;
			
				! Creating stopwatch for the generation time
				ReferenceTime_Generation := CurrentToString("%c%y-%m-%d %H:%M:%S");
			
				StatusMessage("IYP... Generating GMP for period: " + ipss + " of " + periods_selection);
			
				!Apply the desired intra-year method
				if (IntrayearValue='Pstock') then
					!Solve LeastCostOperation
					AY_GMP(ipss) := GMP::Instance::Generate(LeastCostOperation, "GMP_" + ipss);
					if not AY_GMP(ipss) then raise warning "Could not generate the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				elseif (IntrayearValue='min-max') then
					!Solve LeastCostPlanning
					AY_GMP(ipss) := GMP::Instance::Generate(LeastCostPlanning, "GMP_" + ipss);
					if not AY_GMP(ipss) then raise warning "Could not generate the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				endif;
			
				StatusMessage("IYP... Presolving GMP for period: " + ipss + " of " + periods_selection);
				pres_AY_GMP(ipss) := GMP::Instance::CreatePresolved(AY_GMP(ipss), "pres_GMP_" + ipss);
				if not pres_AY_GMP(ipss) then raise warning "Could not presolve the GMP for period "+ipss; AIMMSWav(Failed); return; endif;
				GMP::Instance::SetSolver(pres_AY_GMP(ipss),SolverChoiceIYP);
			
				MathProgramParameters('Generation Time',run_numberState) := round(CurrentToMoment([minute],ReferenceTime_Generation),2);
			
				if pres_AY_GMP(ipss) then
					AY_SolverSession(ipss) := GMP::Instance::CreateSolverSession(pres_AY_GMP(ipss),"SS_" + ipss);
					ProgressWindow := GMP::SolverSession::CreateProgressCategory(AY_SolverSession(ipss));
					GMP::Solution::RetrieveFromModel(pres_AY_GMP(ipss),1);
					MathProgramParameters('Number of Constraints',run_numberState) := GMP::Instance::GetNumberOfRows(pres_AY_GMP(ipss));
					MathProgramParameters('Number of Variables',run_numberState) := GMP::Instance::GetNumberOfColumns(pres_AY_GMP(ipss));
					MathProgramParameters('Number of Nonzeros',run_numberState) := GMP::Instance::GetNumberOfNonzeros(pres_AY_GMP(ipss));
				elseif AY_GMP(ipss) then
					raise warning " ===== Presolving of period " + ipss +" failed. Solving the original GMP instead.";
					AY_SolverSession(ipss) := GMP::Instance::CreateSolverSession(AY_GMP(ipss),"SS_" + ipss);
					ProgressWindow := GMP::SolverSession::CreateProgressCategory(AY_SolverSession(ipss));
					GMP::Solution::RetrieveFromModel(AY_GMP(ipss),1);
					MathProgramParameters('Number of Constraints',run_numberState) := GMP::Instance::GetNumberOfRows(AY_GMP(ipss));
					MathProgramParameters('Number of Variables',run_numberState) := GMP::Instance::GetNumberOfColumns(AY_GMP(ipss));
					MathProgramParameters('Number of Nonzeros',run_numberState) := GMP::Instance::GetNumberOfNonzeros(AY_GMP(ipss));
				endif;
			
				GMP::Solution::SendToSolverSession(AY_SolverSession(ipss),1);
			
				StatusMessage("IYP... AsynchronousExecute period: " + ipss + " of " + periods_selection);
				GMP::SolverSession::AsynchronousExecute(AY_SolverSession(ipss));
			
				run_numberState:= run_numberState + 1;
			
				!Play the alarm
				AIMMSWav(Signal);
			
			endfor;
			
			run_numberState:= 2;
			
			while card(AllsolverSessions) do
			 	FinishedSS := GMP::SolverSession::WaitForSingleCompletion(solSesSet : AllSolverSessions);
			 	for (ipss in periods_selection) do
			 		if StringOccurrences(FinishedSS,ipss)>0 then
			 			StatusMessage("IYP... Retrieveing solution for period " + ipss);
			 			periods_solve:=ipss;
						GMP::Solution::RetrieveFromSolverSession(AY_SolverSession(ipss), 1);
						if pres_AY_GMP(ipss) then
							if (GMP::Solution::GetProgramStatus(pres_AY_GMP(ipss),1) <> 'Optimal') then
								raise warning " ===== Could not find Optimal solution for GMP of period " + ipss +" of " + SetAsString(periods_selection);
								! Get Progress window parameters for reporting purposes
								GMP_details(run_numberState,pres_AY_GMP(ipss),ReferenceTime_IYP);
								periods_selection := periods_selection - ipss;
								run_numberState:=run_numberState+1;
								AIMMSWav(Failed);
								return;
							endif;
							GMP::Solution::SendToModel(pres_AY_GMP(ipss), 1);
							! Get Progress window parameters for reporting purposes
							GMP_details(run_numberState,pres_AY_GMP(ipss),ReferenceTime_IYP);
							run_numberState:=run_numberState+1;
						elseif AY_GMP(ipss) then
							if (GMP::Solution::GetProgramStatus(AY_GMP(ipss),1) <> 'Optimal') then
								raise warning " ===== Could not find Optimal solution for GMP of period " + ipss +" of " + SetAsString(periods_selection);
								! Get Progress window parameters for reporting purposes
								GMP_details(run_numberState,AY_GMP(ipss),ReferenceTime_IYP);
								periods_selection := periods_selection - ipss;
								run_numberState:=run_numberState+1;
								AIMMSWav(Failed);
								return;
							endif;
							GMP::Solution::SendToModel(AY_GMP(ipss), 1);
							! Get Progress window parameters for reporting purposes
							GMP_details(run_numberState,AY_GMP(ipss),ReferenceTime_IYP);
							run_numberState:=run_numberState+1;
						endif;
			
						!Write the outcomes of each year solution
						Ptech_use(t,ipss):=tech_use(t,ipss);
						Ptech_useHourly(h,th,ipss):=tech_useHourly(h,th,ipss);
						Ptech_useDaily(d,td,ipss):=tech_useDaily(d,td,ipss);
						PdeltaQ_UP(h,tf,ipss):=deltaQ_UP(h,tf,ipss);
						PdeltaQ_DW(h,tf,ipss):=deltaQ_DW(h,tf,ipss);
						PdeltaQ_S(h,tfb,ipss):=deltaQ_S(h,tfb,ipss);
						PdeltaQd_UP(d,tfl,ipss):=deltaQd_UP(d,tfl,ipss);
						PdeltaQd_DW(d,tfl,ipss):=deltaQd_DW(d,tfl,ipss);
						PdeltaU_CHP(h,tk,ipss):=deltaU_CHP(h,tk,ipss);
						PdeltaB_UP(d,tg,ipss):=deltaB_UP(d,tg,ipss);
						PdeltaB_DW(d,tg,ipss):=deltaB_DW(d,tg,ipss);
						PdeltaB_S(d,tg,ipss):=deltaB_S(d,tg,ipss);
						PdeltaP_CHP(h,tk,ipss):=deltaP_CHP(h,tk,ipss);
						PdeltaS_shed(h,ts,ipss):=deltaS_shed(h,ts,ipss);
						Ptotal_costs:=Ptotal_costs+totalCosts_planning*period_weightSTAIR(ipss); !Change this one accordingly with SIMULTANEOUS to ensure a good comparisson
						!Save intrayear prices
						hourly_prices(h,ah,ipss):=balance_activitiesHourly(h,ah,ipss).ShadowPrice;
						daily_prices(d,ad,ipss):=balance_activitiesDaily(d,ad,ipss).ShadowPrice;
			
			    			GMP::Instance::DeleteSolverSession(FinishedSS) ;
			    			if pres_AY_GMP(ipss) then GMP::Instance::Delete(pres_AY_GMP(ipss)); endif;
			    			if AY_GMP(ipss) then GMP::Instance::Delete(AY_GMP(ipss)); endif;
			    			periods_selection := periods_selection - ipss;
			 		endif;
			 		StatusMessage("IYP... Periods " + periods_selection + "  are not solved yet!");
			 	endfor;
			    	if card(periods_selection) = 0 then BREAK; endif;
			endwhile ;
			
			! Calculate the elapsed time for reporting purposes
			MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
			! Write model version
			MathProgramParameters('Model Version',1) := project_name;
			
			! Creat a directory for Output files
			if (DirectoryExists("Output/"+OutputFolderName) = 0) then DirectoryCreate("Output/"+OutputFolderName); endif;
			
			!Save the data file
			StatusMessage("Copying the input datafile ..." );
			FileCopy(DataReadingLocation,"Output/"+FindReplaceStrings(DataReadingLocation,"data\\",""));
			
			!Save the temp case file
			StatusMessage("Saving the temp Case as a datafile ..." );
			CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data",AllIdentifiers);
			
			!Round the post processing routines before saving and writing the data.
			EmissionAdjustment;
			EnergyCosts_calculator;
			PostProcessParameters;
			RoundParameters;
			
			!Save the case file
			StatusMessage("Saving the Case as a datafile ..." );
			CaseFileSave("Output/"+OutputFolderName+"/"+OutputFolderName+".data",AllIdentifiers);
			FileDelete("Output/"+OutputFolderName+"/"+OutputFolderName+"_temp.data");
			
			! Calculate the elapsed time for reporting purposes
			MathProgramParameters('Total Run Time',1) := round(CurrentToMoment([minute],ReferenceTime),2) + " [min]";
			
			!Write the output of the model
			StatusMessage("IYP... Writing the excel outputs ..." );
			runDataWritingTransition;
			
			!!First remove all the solversessions that currently might be active
			!while card(IndexSolverSessions) do
			!	gmp::Instance::DeleteSolverSession( first(IndexSolverSessions) ) ;
			!endwhile ;
			!
			!!Now remove any of the GMPs that might still be present
			!while card(IndexGeneratedMathematicalPrograms) do
			!	gmp::Instance::Delete( first(IndexGeneratedMathematicalPrograms) ) ;
			!endwhile ;
			
			!Play the alarm
			AIMMSWav(Finalized);
			
			StatusMessage("Intra-year pricing is finished!" );
		}
		Comment: {
			"Add initialization statements here that require that the libraries are already initialized properly,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure MainExecution {
		Body: {
			!
			!
			!option Presolve_feasibility_tolerance:= 1e-8;
			!SolverChoiceTransition := 'GUROBI 9.1';
			!
			!SolveTransition;
			!
			!!FinishedSS := GMP::SolverSession::WaitForSingleCompletion(solSesSet : AllSolverSessions);
			!!GMP::Instance::DeleteSolverSession(FinishedSS) ;
			!
			!SolverChoiceTransition := 'CPLEX 20.1';
			!IntrayearValue := 'Pstock';
			!option Presolve_feasibility_tolerance:= 1e-8;
			!option scale_model:= 'On';
			!
			!IntraYearPrices;
			!
		}
	}
	Procedure ReadfromText {
		Body: {
			!read from file "IESAOpt.ams";
		}
	}
	Procedure WritetoText {
		Body: {
			!write to file "IESAOpt4.3.txt" in replace mode !!and now there are other changes;
		}
	}
}
